
/*
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *              http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

/dts-v1/;
/plugin/;
/ {
	fragment@smd {
		target-path = "/";
		__overlay__ {
			smd: samsung_mobile_device {
				compatible = "simple-bus";
			};
		};
	};
};

/* #include "../samsung_common_6_6.dtsi" */          /* From samsung_common_6_6.py */
/ {
	fragment@samsung_common {
		target-path = "/";
		__overlay__ {
#if defined(CONFIG_SEC_FACTORY)
			sec_reloc_gpio: samsung,reloc_gpio {
				compatible = "samsung,reloc_gpio";
				status = "okay";
				/* see, '/sys/kernel/debug/pinctrl' */
				sec,gpio-label = "reloc_gpio";
				sec,reloc-base = <0>;
			};
#endif
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/samsung/slsi/common/6.6/dts/samsung_common_6_6._ap_slsi_s5e8855.dtsi */
/ {
	fragment@samsung_bootstat {
		target-path = "/";
		__overlay__ {
			sec-bootstat {
				thermal-zones {
					/* max number of thermal-zones is 10 */
					/* max length of display-name is 4 */
					zone_big {
						zone-name = "BIG";
						display-name = "BIG";
					};
					zone_mid {
						zone-name = "MID";
						display-name = "MID";
					};
					zone_lit {
						zone-name = "LITTLE";
						display-name = "LIT";
					};
					zone_g3d {
						zone-name = "G3D";
						display-name = "G3D";
					};
					zone_isp {
						zone-name = "ISP";
						display-name = "ISP";
					};
					zone_npu {
						zone-name = "NPU";
						display-name = "NPU";
					};
					zone_bat {
						zone-name = "battery";
						display-name = "BAT";
					};
				};
			};
		};
	};
};

/* #include "../samsung_debug_6_6.dtsi" */           /* From samsung_debug_6_6.py */
/* SAMSUNG s5e9955 board device tree source
 *
 * Copyright (c) 2024 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@sec_debug {
		target-path = "/";
		__overlay__ {
			sec_debug {
				compatible = "samsung,sec_debug";
				status = "okay";
				memory-region = <&sec_debug_next>;
				bdev_path = "/dev/block/by-name/debug";
			};
		};
	};

	fragment@sec_debug_built {
		target-path = "/";
		__overlay__ {
			sec_debug_built {
				compatible = "samsung,sec_debug_built";
				status = "okay";
				memory-region = <&sec_debug_next>;
			};
		};
	};

	fragment@sec_debug_test {
		target-path = "/";
		__overlay__ {
			sec_debug_test_device {
				compatible = "samsung,sec_debug_test";
				status = "okay";
			};
		};
	};

	fragment@sec_debug_reset_reason {
		target-path = "/";
		__overlay__ {
			sec_debug_reset_reason: sec_debug_reset_reason {
				compatible = "samsung,sec_debug_reset_reason";
				/*
				 * power_off_src = [OFFSRC2[0],...,[7],]OFFSRC1[0],...,[7]
				 * power_on_src = [ONSRC2[0],...,[7],]ONSRC1[0],...,[7]
				 * rst_stat = RST_STAT[0],...,[31]
				 */
				power_off_src = "OVP", "BUCK_OI", "LDO_OI", "RSVD3",
						"RSVD4", "RSVD5", "RSVD6", "RSVD7",
						"SUB_OFF", "TSD", "TIMEOUT", "LDO_SYS_OK",
						"PWRHOLD", "WTSR_TOUT", "SMPL_TOUT", "UVLOB";
				power_on_src =  "RSVD0", "RSVD1", "RSVD2", "RSVD3",
						"INST_JIGON", "RSVD5", "RSVD6", "RSVD7",
						"PWRON", "JIGONB", "ACOKB", "MRST",
						"ALARM", "INST_ACOK", "SMPL", "WTSR";
				rst_stat = "RSVD0", "RSVD1", "RSVD2", "RSVD3",
					"RSVD4", "RSVD5", "RSVD6", "RSVD7",
					"RSVD8", "RSVD9", "RSVD10", "RSVD11",
					"RSVD12", "RSVD13", "RSVD14", "RSVD15",
					"PINRESET", "DNC_CPU_WDTRESET", "SSP_CPU_WDTRESET", "OIS_CPU_WDTRESET",
					"APM_CPU0_WDTRESET", "APM_CPU1_WDTRESET", "VTS_CPU_WDTRESET", "CHUB_WDTRESET",
					"CLUSTER0_WDTRESET", "CLUSTER3_WDTRESET", "AUD_CPU0_WDTRESET", "SSS_CPU_WDTRESET",
					"DBGC_CPU_WDTRESET", "WRESET", "SWRESET", "PORESET";
			};
		};
	};
};

&reserved_memory {
	sec_debug_next: sec_debug_next {
		reg = <0x0 0x91200000 0x00200000>;
		no-map;
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/samsung/slsi/debug/6.6/dts/samsung_debug_6_6._ap_slsi_s5e8855.dtsi */

&sec_debug_reset_reason {
	rst_stat = "RSVD0", "RSVD1", "RSVD2", "RSVD3",
		"RSVD4", "RSVD5", "RSVD6", "RSVD7",
		"RSVD8", "RSVD9", "RSVD10", "RSVD11",
		"RSVD12", "RSVD13", "RSVD14", "RSVD15",
		"PINRESET", "DNC_CPU_WDTRESET", "PSP_CPU_WDTRESET", "OIS_CPU_WDTRESET",
		"APM_CPU0_WDTRESET", "APM_CPU1_WDTRESET", "VTS_CPU_WDTRESET", "CHUB_WDTRESET",
		"CLUSTER0_WDTRESET", "CLUSTER1_WDTRESET", "AUD_CPU0_WDTRESET", "RSVD27",
		"DBGC_CPU_WDTRESET", "WRESET", "SWRESET", "PORESET";
};

/* #include "../vibrator_vib_info.dtsi" */           /* From vibrator_vib_info.py */

&smd {
	vib_info: vibrator_info {
		status = "okay";
		compatible = "samsung,vib-info";
		functions = "INTENSITY", "HAPTIC_ENGINE", "INDEX_HAPTIC_PATTERN", "HYBRID_PATTERN_COMMON_INPUTFF", "PRIMITIVE_EFFECT_COMPOSE", "COMMON_INPUTFF_INTERFACE";
#if 1
		samsung,intensities = <0 2000 4000 6000 8000 10000>;
#else
		samsung,intensities = <>;
#endif

#if 0
		samsung,haptic_intensities = <>;
#else
		samsung,haptic_intensities = <0 3000 5000 6700 8400 10000>;
#endif
	};
};

/* #include "../display_s6e3fc5_a56x.dtsi" */        /* From display_s6e3fc5_a56x.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include <dt-bindings/display/exynos-display.h>
#include "../display_s6e3fc5_a56x_adaptive_mipi.dtsi"

&dsim_modes {
	1080x2340@120hs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <1842>;
	};
	1080x2340@60phs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <1842>;
	};
	1080x2340@60hs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <7556>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <18983>;
	};
};

&drmdsim_0 {
	hs_pll_timing = <&dsim_hs_pll_timing>;
};

/ {
	fragment@panel_display_mode {
		target-path = "/";
		__overlay__ {
			a56x_fc5_panel_dsc_picture_parameter_set_fhd:
			a56x_fc5_panel_dsc_picture_parameter_set_fhd {
					picture_parameter_set = /bits/ 8 <
						0x11 0x00 0x00 0x89 0x30 0x80 0x09 0x24
						0x04 0x38 0x00 0x1E 0x02 0x1C 0x02 0x1C
						0x02 0x00 0x02 0x0E 0x00 0x20 0x02 0xE3
						0x00 0x07 0x00 0x0C 0x03 0x50 0x03 0x64
						0x18 0x00 0x10 0xF0 0x03 0x0C 0x20 0x00
						0x06 0x0B 0x0B 0x33 0x0E 0x1C 0x2A 0x38
						0x46 0x54 0x62 0x69 0x70 0x77 0x79 0x7B
						0x7D 0x7E 0x01 0x02 0x01 0x00 0x09 0x40
						0x09 0xBE 0x19 0xFC 0x19 0xFA 0x19 0xF8
						0x1A 0x38 0x1A 0x78 0x1A 0xB6 0x2A 0xF6
						0x2B 0x34 0x2B 0x74 0x3B 0x74 0x6B 0xF4
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
					>;
			};
			a56x_fc5_panel_display_modes:
			a56x_fc5_panel_display_modes {
				native-mode = <&a56x_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&a56x_panel_display_mode_1080x2340_120hs
					&a56x_panel_display_mode_1080x2340_60phs
					&a56x_panel_display_mode_1080x2340_60hs
					&a56x_panel_display_mode_1080x2340_30ns
				>;

				/* fhd */
				a56x_panel_display_mode_1080x2340_120hs:
				a56x_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_fc5_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <1842>;
				};

				a56x_panel_display_mode_1080x2340_60phs:
				a56x_panel_display_mode_1080x2340_60phs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS_120HS_TE_SW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_fc5_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <1842>;
				};

				a56x_panel_display_mode_1080x2340_60hs:
				a56x_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <2432 0 0>;	/* panel vbp:12, vfp:2420, but for ap vblank set vbp:12+2420, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_fc5_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <7556>;
				};

				a56x_panel_display_mode_1080x2340_30ns:
				a56x_panel_display_mode_1080x2340_30ns {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_fc5_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <18983>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};


/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				s6e3fc5_a56x_power_ctrl:
				s6e3fc5_a56x_power_ctrl {
					actions {
						fc5_a56x_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						fc5_a56x_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						fc5_a56x_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						fc5_a56x_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						fc5_a56x_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						fc5_a56x_delay_11ms: delay-11ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <11>;
						};
						fc5_a56x_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						fc5_a56x_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
						fc5_a56x_vci_set_3p0: vci-set-3p0 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddi_vci>;
							value = <3000000>;
						};
					};
					sequences {
						panel_boot_on = <&fc5_a56x_vci_set_3p0 &fc5_a56x_vci_on &fc5_a56x_vdd3_on>;
						panel_power_on = <&fc5_a56x_vci_set_3p0 &fc5_a56x_vci_on &fc5_a56x_vdd3_on &fc5_a56x_delay_11ms &fc5_a56x_reset_high &fc5_a56x_delay_11ms>;
						panel_power_off = <&fc5_a56x_reset_low &fc5_a56x_delay_1ms &fc5_a56x_vci_off &fc5_a56x_delay_11ms &fc5_a56x_vdd3_off>;
					};
				};

				s6e3fc5_55x_ap:s6e3fc5_55x_ap {
					/* S.LSI */
					SLSI,size = <71 153>;       /* 70.524 x 152.802 */
					SLSI,hdr_formats = <(HDR_FORMAT_HDR10 | HDR_FORMAT_HLG | HDR_FORMAT_HDR10P)>;
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
				};

				panels {
					/* find s6e3fc5_a56x panel header */
					s6e3fc5_a56x: s6e3fc5_a56x {
						ap-vendor-setting = <&s6e3fc5_55x_ap>;
						display-mode = <&a56x_fc5_panel_display_modes>;
						power-ctrl = <&s6e3fc5_a56x_power_ctrl>;
						dqe-suffix = "s6e3fc5_a56x";
						sdp-adaptive-mipi = <&s6e3fc5_a56x_sdp_adaptive_mipi_info>;
						id-mask = <
							PANEL_ID(0x000000) PANEL_MASK(0x0000F0)
							PANEL_ID(0x000000) PANEL_MASK(0x000000)
						>;
					};
				};
			};
		};
	};
};


/* #include "../sensorhub_shub.dtsi" */              /* From sensorhub_shub.py */
#if 0
&${sensor_vdd_1p8} {
	regulator-name = "VDD_SENSOR_1P8";
};
#endif
#if 0
&${gpio_sensor_ldo_en_parent} {
	shub_sensor_ldo_en: shub-sensor-ldo-en {
		samsung,pins = SEC_GPIO(${gpio_sensor_ldo_en});
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};
#endif
#if 0
&${gpio_prox_ldo_en_parent} {
	shub_prox_ldo_en: shub-prox-ldo-en {
		samsung,pins = SEC_GPIO(${gpio_prox_ldo_en});
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};
#endif
#if 0
&${gpio_pogo_int_parent} {
	shub_pogo_int: shub-pogo-int {
		GPIO_CONFIG_PUD_DRV(${gpio_pogo_int}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};
#endif
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				pinctrl-names = "default";
#if 0 || 0 || 0
				pinctrl-0 = <
#if 0
				&shub_sensor_ldo_en
#endif
#if 0
				&shub_prox_ldo_en
#endif
#if 0
				&shub_pogo_int
#endif
>;
#endif

#if 0
				sensor-vdd-regulator = "VDD_SENSOR_1P8";
#endif

#if 0
				mag-check-nfc = <SEC_GPIO_REF(${gpio_nfc_check}) 0>;
#endif

#if 0
				pogo-int = <SEC_GPIO_REF(${gpio_pogo_int}) 0>;
#endif

#if 0
				sensor-ldo-en = <SEC_GPIO_REF(${gpio_sensor_ldo_en}) 0>;
#endif
#if 0
				prox-ldo-en = <SEC_GPIO_REF(${gpio_prox_ldo_en}) 0>;
#endif
			};
		};
	};
};

/* #include "../samsung_6_1.dtsi" */                 /* From samsung_6_1.py */
/* SAMSUNG board device tree source
 *
 * Copyright (c) 2021 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			sec-reboot {
				compatible = "samsung,sec-reboot";
				samsung,syscon-phandle = <&pmu_system_controller>;
				shutdown-offset = <0x3F90>; /* PS_HOLD_CONTROL */
				shutdown-trigger = <0x100>; /* PS_HOLD_DATA_BIT */
				magic-inform = <0x00B8>; /* INFORM2 */
				panic-inform = <0x00BC>; /* INFORM3 */
			};
		};
	};
};

/* #include "../sec_pinctrl_wrapper_v3.dtsi" */      /* From sec_pinctrl_wrapper_v3.py */
#define ___count_args(_0, _1, _2, _3, _4, _5, _6, _7, _8, x, ...) x

#define __count_args(...)					\
	___count_args(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)

#define PIN_AP_FUNC_INPUT		0x0
#define PIN_AP_FUNC_OUTPUT		0x1
#define PIN_AP_FUNC_OUTPUT_HIGH		0x1
#define PIN_AP_FUNC_OUTPUT_LOW		0x1
#define PIN_AP_FUNC_INPUT_WAKEUP	0xf

#define PIN_AP_VAL_FUNC_INPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT		0x0
#define PIN_AP_VAL_FUNC_OUTPUT_HIGH	0x1
#define PIN_AP_VAL_FUNC_OUTPUT_LOW	0x0
#define PIN_AP_VAL_FUNC_INPUT_WAKEUP	0x0


#define PIN_PM_FUNC_INPUT		pmic-gpio,input-enable
#define PIN_PM_FUNC_OUTPUT		pmic-gpio,output-enable
#define PIN_PM_FUNC_OUTPUT_HIGH		pmic-gpio,output-high
#define PIN_PM_FUNC_OUTPUT_LOW		pmic-gpio,output-low

#define PIN_AP_FUNC_PWM			0x2
#define PIN_AP_FUNC_I2C			0x2

#define PIN_PULL_NONE	0
#define PIN_PULL_DOWN	1
#define PIN_PULL_UP	3

#define PIN_PM_PULL_NONE	pmic-gpio,pull-disable
#define PIN_PM_PULL_DOWN	pmic-gpio,pull-down
#define PIN_PM_PULL_UP		pmic-gpio,pull-up

/*
 * Typical GPIO
 * 0x0 | 2 mA
 * 0x1 | 4 mA
 * 0x2 | 8 mA
 * 0x3 | 12 mA
 */

#define PIN_AP_DRV_LV1	0x0
#define PIN_AP_DRV_LV2	0x1
#define PIN_AP_DRV_LV3	0x1
#define PIN_AP_DRV_LV4	0x2
#define PIN_AP_DRV_LV5	0x2
#define PIN_AP_DRV_LV6	0x3
#define PIN_AP_DRV_LV7	0x3
#define PIN_AP_DRV_LV8	0x3

#define PIN_PM_DRV_LV1	0x0
#define PIN_PM_DRV_LV2	0x1
#define PIN_PM_DRV_LV3	0x2
#define PIN_PM_DRV_LV4	0x3
#define PIN_PM_DRV_LV5	0x4
#define PIN_PM_DRV_LV6	0x5
#define PIN_PM_DRV_LV7	0x5
#define PIN_PM_DRV_LV8	0x5

#define PIN_EXPAND(pin) #pin

#define GPIO_KEY_WAKEUP		gpio-key,wakeup
#define GPIO_KEY_NONE		gpio-key,none
#define GPIO_KEY_CAN_DISABLE	linux,can-disable

#define SEC_GPIO(src, handle, type, num)	SEC_ ##src## _GPIO(type, num)
#define SEC_AP_GPIO(type, num)	PIN_EXPAND(type##-num)
#define SEC_PM_GPIO(type, num)	PIN_EXPAND(type ##num)

#define SEC_GPIO_REF(src, handle, type, num)	SEC_ ##src## _GPIO_REF(handle, num)
#define SEC_AP_GPIO_REF(handle, num)	&handle num
#define SEC_PM_GPIO_REF(handle, num)	&handle num
#define SEC_GPIO_PHANDLE_ACTIVE(src, type, num)	SEC_GPIO_PHANDLE(type, num, active)
#define SEC_GPIO_PHANDLE_SLEEP(src, type, num)	SEC_GPIO_PHANDLE(type, num, sleep)
#define SEC_GPIO_PHANDLE(type, num, mode)	type##_##num##_##mode

#define SEC_GPIO_NUM(src, handle, type, num)	num

#define SEC_GPIO_TYPE(src, handle, type, num)	&handle

#define GPIO_CONFIG(src, handle, type, num, func)			GPIO_ ##src## _CONFIG(type, num, func)
#define GPIO_CONFIG_PUD(src, handle, type, num, func, pull)		GPIO_ ##src## _CONFIG_PUD(type, num, func, pull)
#define GPIO_CONFIG_PUD_DRV(src, handle, type, num, func, pull, drv)	GPIO_ ##src## _CONFIG_PUD_DRV(type, num, func, pull, drv)

#define GPIO_AP_CONFIG(_type, _num, _func)		\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>

#define GPIO_AP_CONFIG_PUD(_type, _num, _func, _pull)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);	\
	samsung,pin-function = <PIN_AP_ ##_func>;	\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;		\
	samsung,pin-pud = <PIN_ ##_pull>

#define GPIO_AP_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	samsung,pins = SEC_AP_GPIO(_type, _num);		\
	samsung,pin-function = <PIN_AP_ ##_func>;		\
	samsung,pin-val = <PIN_AP_VAL_ ##_func>;			\
	samsung,pin-pud = <PIN_ ##_pull>;			\
	samsung,pin-drv = <PIN_AP_ ##_drv>

#define GPIO_PM_CONFIG(_type, _num, _func)		\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func				

#define GPIO_PM_CONFIG_PUD(_type, _num, _func, _pull)	\
	pins = SEC_PM_GPIO(_type, _num);		\
	PIN_PM_ ##_func;				\
	PIN_PM_ ##_pull

#define GPIO_PM_CONFIG_PUD_DRV(_type, _num, _func, _pull, _drv)	\
	pins = SEC_PM_GPIO(_type, _num);			\
	PIN_PM_ ##_func;					\
	PIN_PM_ ##_pull;					\
	pmic-gpio,drive-strength = <PIN_PM_ ##_drv>

#define SEC_ADC(type, num) <&type num>
#define SEC_ADC_OPT(type, num) ,<&type num>

#define GPIO_KEY_CONFIG(_code, _gpio, _wakeup, _interval)	\
	label = PIN_EXPAND(_code);							\
	linux,code = <_code>;						\
	gpios = <_gpio 0xf>;						\
	GPIO_KEY_ ##_wakeup;						\
	debounce-interval = <_interval>

#define SEC_INTERFACE_REF(type, num)	&type num


/* #include "../display_ana6710_a56x.dtsi" */        /* From display_ana6710_a56x.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>
#include <dt-bindings/display/exynos-display.h>
#include "../display_ana6710_a56x_adaptive_mipi.dtsi"

&dsim_modes {
	1080x2340@120hs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <1842>;
	};
	1080x2340@60phs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <1842>;
	};
	1080x2340@60hs {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <7556>;
	};
	1080x2340@30ns {
		exynos,pmsk = <
			0x7 0xCD 0x1 0xE555
			0xB 0x3 0x1 0x0
			0x0 0x0 0x0 0x0
			0x0 0x0
			>;
		exynos,hs-clk = <1124>;
		exynos,esc-clk = <20>;
		exynos,cmd_underrun_cnt = <18983>;
	};
};

&drmdsim_0 {
	hs_pll_timing = <&dsim_hs_pll_timing>;
};

/ {
	fragment@panel_display_mode {
		target-path = "/";
		__overlay__ {
			a56x_ana6710_panel_dsc_picture_parameter_set_fhd:
			a56x_ana6710_panel_dsc_picture_parameter_set_fhd {
					picture_parameter_set = /bits/ 8 <
						0x11 0x00 0x00 0x89 0x30 0x80 0x09 0x24
						0x04 0x38 0x00 0x1E 0x02 0x1C 0x02 0x1C
						0x02 0x00 0x02 0x0E 0x00 0x20 0x02 0xE3
						0x00 0x07 0x00 0x0C 0x03 0x50 0x03 0x64
						0x18 0x00 0x10 0xF0 0x03 0x0C 0x20 0x00
						0x06 0x0B 0x0B 0x33 0x0E 0x1C 0x2A 0x38
						0x46 0x54 0x62 0x69 0x70 0x77 0x79 0x7B
						0x7D 0x7E 0x01 0x02 0x01 0x00 0x09 0x40
						0x09 0xBE 0x19 0xFC 0x19 0xFA 0x19 0xF8
						0x1A 0x38 0x1A 0x78 0x1A 0xB6 0x2A 0xF6
						0x2B 0x34 0x2B 0x74 0x3B 0x74 0x6B 0xF4
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
						0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
					>;
			};
			a56x_ana6710_panel_display_modes:
			a56x_ana6710_panel_display_modes {
				native-mode = <&a56x_ana6710_panel_display_mode_1080x2340_120hs>;
				exposed-mode = <
					&a56x_ana6710_panel_display_mode_1080x2340_120hs
					&a56x_ana6710_panel_display_mode_1080x2340_60phs
					&a56x_ana6710_panel_display_mode_1080x2340_60hs
					&a56x_ana6710_panel_display_mode_1080x2340_30ns
				>;

				/* fhd */
				a56x_ana6710_panel_display_mode_1080x2340_120hs:
				a56x_ana6710_panel_display_mode_1080x2340_120hs {
					id = PANEL_DISPLAY_MODE_1080x2340_120HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <120>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_ana6710_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <1842>;
				};

				a56x_ana6710_panel_display_mode_1080x2340_60phs:
				a56x_ana6710_panel_display_mode_1080x2340_60phs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS_120HS_TE_SW_SKIP_1;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_PASSIVE_HS>;
					panel_refresh_rate = <120>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <1>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_ana6710_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <1842>;
				};

				a56x_ana6710_panel_display_mode_1080x2340_60hs:
				a56x_ana6710_panel_display_mode_1080x2340_60hs {
					id = PANEL_DISPLAY_MODE_1080x2340_60HS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <60>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_HS>;
					panel_refresh_rate = <60>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_HS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <2432 0 0>;	/* panel vbp:12, vfp:2420, but for ap vblank set vbp:12+2420, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_ana6710_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <7556>;
				};

				a56x_ana6710_panel_display_mode_1080x2340_30ns:
				a56x_ana6710_panel_display_mode_1080x2340_30ns {
					id = PANEL_DISPLAY_MODE_1080x2340_30NS;
					width = <1080>;
					height = <2340>;
					/* timing parameters */
					refresh_rate = <30>;			/* logical refresh rate */
					refresh_mode = <REFRESH_MODE_NS>;
					panel_refresh_rate = <30>;		/* panel internal refresh rate */
					panel_refresh_mode = <PANEL_REFRESH_MODE_NS>;
					panel_te_st = <0>;				/* te rising */
					panel_te_ed = <0>;				/* te falling */
					panel_te_sw_skip_count = <0>;	/* s/w te modulation */
					panel_te_hw_skip_count = <0>;	/* h/w te modulation */
					panel_h_porch = <0 0 0>;
					panel_v_porch = <16 0 0>;	/* panel vbp:12, vfp:4, but for ap vblank set vbp:12+4, vfp:0 */
					/* dsc parameters */
					dsc_en = <1>;			/* 0:Disable, 1:Enable */
					dsc_cnt = <2>;			/* used DSC count */
					dsc_slice_num = <2>;	/* count of dsc slice */
					dsc_slice_w = <540>;	/* width of dsc slice */
					dsc_slice_h = <30>;	/* height of dsc slice */
					dsc_picture_parameter_set = <&a56x_ana6710_panel_dsc_picture_parameter_set_fhd>;
					/* dsi parameters */
					cmd_lp_ref = <18983>;
					doze_mode;
					panel_lp_mode;
				};
			};
		};
	};
};


/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;

				ana6710_a56x_power_ctrl:
				ana6710_a56x_power_ctrl {
					actions {
						ana6710_a56x_vci_on: vci-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_a56x_vdd3_on: vdd3-on {
							type = <PCTRL_REGULATOR_ENABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_a56x_vci_off: vci-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vci>;
						};
						ana6710_a56x_vdd3_off: vdd3-off {
							type = <PCTRL_REGULATOR_DISABLE>;
							reg = <&ddi_vdd3>;
						};
						ana6710_a56x_delay_1ms: delay-1ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <1>;
						};
						ana6710_a56x_delay_2ms: delay-2ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <2>;
						};
						ana6710_a56x_delay_11ms: delay-11ms {
							type = <PCTRL_DELAY_MSLEEP>;
							value = <11>;
						};
						ana6710_a56x_delay_21ms: delay-21ms {
							type = <PCTRL_DELAY_USLEEP>;
							value = <21000>;
						};
						ana6710_a56x_reset_high: reset-high {
							type = <PCTRL_GPIO_ENABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_a56x_reset_low: reset-low {
							type = <PCTRL_GPIO_DISABLE>;
							gpio = <&disp_reset>;
						};
						ana6710_a56x_vci_set_3p0: vci-set-3p0 {
							type = <PCTRL_REGULATOR_SET_VOLTAGE>;
							reg = <&ddi_vci>;
							value = <3000000>;
						};
					};
					sequences {
						panel_boot_on = <
								&ana6710_a56x_vci_set_3p0
								&ana6710_a56x_vci_on
								&ana6710_a56x_vdd3_on
						>;
						panel_power_on = <
								&ana6710_a56x_vdd3_on
								&ana6710_a56x_delay_1ms
								&ana6710_a56x_vci_set_3p0
								&ana6710_a56x_vci_on
								&ana6710_a56x_delay_21ms
								&ana6710_a56x_reset_high
								&ana6710_a56x_delay_11ms
						>;
						panel_power_off = <
								&ana6710_a56x_delay_2ms
								&ana6710_a56x_reset_low
								&ana6710_a56x_delay_1ms
								&ana6710_a56x_vci_off
								&ana6710_a56x_delay_11ms
								&ana6710_a56x_vdd3_off
						>;
					};
				};

				ana6710_a56x_ap:ana6710_a56x_ap {
					/* S.LSI */
					SLSI,size = <71 154>;       /* 71.280 x 154.44 */
					SLSI,hdr_formats = <(HDR_FORMAT_HDR10 | HDR_FORMAT_HLG | HDR_FORMAT_HDR10P)>;
					SLSI,hdr_max_luma = <4500000>;	/* 450 */
					SLSI,hdr_max_avg_luma = <1200000>;	/* 120 */
					SLSI,hdr_min_luma = <5>;		/* 0.0005 */
					/* ignore ANAPASS err-report */
					SLSI,ignore-rx-trail;
				};

				panels {
					/* find ana6710_a56x panel header */
					ana6710_a56x: ana6710_a56x {
						ap-vendor-setting = <&ana6710_a56x_ap>;
						display-mode = <&a56x_ana6710_panel_display_modes>;
						power-ctrl = <&ana6710_a56x_power_ctrl>;
						dqe-suffix = "ana6710_a56x";
						sdp-adaptive-mipi = <&ana6710_a56x_sdp_adaptive_mipi_info>;
						id-mask = <
							PANEL_ID(0x000040) PANEL_MASK(0x0000F0)
						>;
					};
				};
			};
		};
	};
};


/* #include "../nc.dtsi" */                          /* From nc.py */
#define LEGO_IS_USE_NC
#define LEGO_IS_USE(x, ...) !defined(LEGO_IS_USE_##x)

/* #include "../sec_vibrator_inputff.dtsi" */        /* From sec_vibrator_inputff.py */

&smd {
	sec_vib_inputff {
		status = "okay";
		compatible = "sec_vib_inputff";

		haptic,normal_ratio = <100>;
		haptic,overdrive_ratio = <100>;
#if 0
		haptic,fold_string = "";

		haptic,tent_open_ratio = <100>;
		haptic,tent_close_ratio = <100>;

		/* Fold open & close ratio required for vertial motor,
		 * may not be required for Harizontal motor
		 */
		haptic,fold_open_ratio = <100>;
		haptic,fold_close_ratio = <100>;
#endif
		haptic,high_temp_ref = <48>;
		haptic,high_temp_ratio = <70>;
		haptic,f0_cal_way = "MANUAL";
	};
};


/* #include "../abc_spec_manager_type1.dtsi" */      /* From abc_spec_manager_type1.py */
&smd {
	sec_abc {
		compatible = "samsung,sec_abc";
		status = "okay";
		abc_spec_type1 {
			module_list = "gpu", "gpu_qc", "gpu_qc", "camera", "camera", "vib", "tsp", "tsp_sub", "mm", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "camera", "gpu";
			name_list = "gpu_fault", "gpu_fault", "gpu_page_fault", "mipi_overflow", "i2c_fail", "int_gnd_short", "tsp_int_fault", "tsp_int_fault", "venus_hung", "mipi_error_rw1", "mipi_error_rs1", "mipi_error_rt1", "mipi_error_fw1", "mipi_error_rt2", "mipi_error_uw1", "mipi_error_rm1", "mipi_error_rb1", "mipi_error_fs1", "gpu_job_timeout";
#ifndef CONFIG_SEC_FACTORY
			threshold_cnt = <20>, <2>, <20>, <1>, <1>, <25>, <2>, <2>, <10>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <1>, <1>;
			threshold_time = <1200>, <1200>, <1200>, <0>, <0>, <5>, <5>, <5>, <3>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <0>, <0>;
#else
			threshold_cnt = <20>, <2>, <20>, <4>, <4>, <25>, <2>, <2>, <10>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <4>, <1>;
			threshold_time = <1200>, <1200>, <1200>, <120>, <120>, <5>, <5>, <5>, <3>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <120>, <0>;
#endif
		};
	};
};

/* #include "../common/input_booster_s5e8855.dtsi" *//* From input_booster_s5e8855.py */
/*
 * Samsung Mobile Input-Booster device tree
 *
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	input_booster {
		status = "okay";
		compatible = "input_booster";
		resValcount = "3";
		max_resource_count = "7";
		max_cluster_count = "3";
		#address-cells = <1>;
		#size-cells = <0>;

		/* Each Cpu Cluster Start Cpu */
		cpu_cluster_policy = "7,4,0";
		/* < CLUSTER2, CLUSTER1, CLUSTER0, MIF, INT, HMP, UCC> */
		ib_release_values = "0,0,0,0,0,0,0";
		/* Select Allowed Resource Index Group */
		allowed_resources = "0,3,4";
		
		/* Mode Number 
		 *	DEFAULT_MODE = 0;
		 *	DISABLE_MODE = 1;
		 *	SIP_MODE = 2;
		 *	GAME_MODE = 3;
		*/

		booster@1 {
			booster,label = "Disable_Mode";
			booster,mode = "1";
			booster_key@1 {
				input_booster,label = "Touch_Disable";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@2 {
			booster,label = "Sip_Mode";
			booster,mode = "2";
			booster_key@1 {
				input_booster,label = "sip_touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */
				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <1248000 0>;
					};
				};
			};
		};

		booster@3 {
			booster,label = "Game_Mode";
			booster,mode = "3";
			booster_key@1 {
				input_booster,label = "GAME_MT";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */
				/* Time table */
				input_booster,head_time = <0>;
				input_booster,tail_time = <0>;
				input_booster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "CPU";
						resource,id = "0";
						resource,value = <0 0>;
					};
				};
			};
		};

		booster@4 {
			booster,label = "input_booster";
			booster,mode = "0";

			booster_key@1 {
				input_booster,label = "key";
				input_booster,type = <0>;	/* BOOSTER_DEVICE_KEY */

				/* Time table */
				input_booster,head_time = <500>;
				input_booster,tail_time = <0>;

				/* resource Table Sequentially identified with index
				 * CLUSTER2's ID & Index : 0 (or UFC)
				 * CLUSTER1's ID & Index : 1
				 * CLUSTER0's ID & Index : 2
				 * MIF's ID & Index      : 3
				 * INT's ID & Index      : 4
				 * HMP's ID & Index      : 5
				 * UCC's ID & Index      : 6
				 */

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@2 {
				input_booster,label = "touchkey";
				input_booster,type = <1>;	/* BOOSTER_DEVICE_TOUCHKEY */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@3 {
				input_booster,label = "touch";
				input_booster,type = <2>;	/* BOOSTER_DEVICE_TOUCH */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1248000 1152000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 1014000>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@4 {
				input_booster,label = "multitouch";
				input_booster,type = <3>;	/* BOOSTER_DEVICE_MULTITOUCH */

				/* Time table */
				input_booster,head_time = <1000>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1920000 1344000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 1014000>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@5 {
				input_booster,label = "keyboard";
				input_booster,type = <4>;	/* BOOSTER_DEVICE_KEYBOARD */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 1344000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 1014000>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@6 {
				input_booster,label = "MOUSE";
				input_booster,type = <5>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 768000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 1014000>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@7 {
				input_booster,label = "mouse_wheel";
				input_booster,type = <6>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <0>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 0>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 0>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@8 {
				input_booster,label = "pen_hover";
				input_booster,type = <7>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <130>;
				input_booster,tail_time = <500>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1344000 960000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <0 0>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};

			booster_key@9 {
				input_booster,label = "pen";
				input_booster,type = <8>;	/* BOOSTER_DEVICE_MOUSE */

				/* Time table */
				input_booster,head_time = <200>;
				input_booster,tail_time = <600>;

				/* Input Booster Resource Frequency */
				inputbooster,resource {
					compatible = "resource";
					resource@1 {
						resource,label = "cluster2";
						resource,id = "0";
						resource,value = <1728000 1152000>;
					};

					resource@4 {
						resource,label = "mif";
						resource,id = "3";
						resource,value = <1014000 1014000>;
					};

					resource@5 {
						resource,label = "int";
						resource,id = "4";
						resource,value = <0 0>;
					};
				};
			};
			/* If you need to add new key type, add it this position */
		};
	};
};

/* #include "../display_panel_manager.dtsi" */       /* From display_panel_manager.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/display/panel-display.h>

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
#if 0
			panel_drv_${PANEL_DRV_ID}: panel_drv_${PANEL_DRV_ID} {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <${PANEL_DRV_ID}>;
#else
			panel_drv_0: panel_drv_0 {
				status = "okay";
				compatible = "samsung,panel-drv";
				panel,id = <0>;
#endif

				panel-lut {
#if 1
					panel_0 = <&ana6710_a56x>;
#endif
#if 1
					panel_1 = <&s6e3fc5_a56x>;
#endif
#if 0
					panel_2 = <&${panel_name_2}>;
#endif
#if 0
					panel_3 = <&${panel_name_3}>;
#endif
#if 0
					panel_4 = <&${panel_name_4}>;
#endif
#if 0
					panel_5 = <&${panel_name_5}>;
#endif
#if 0
					panel_6 = <&${panel_name_6}>;
#endif
#if 0
					panel_7 = <&${panel_name_7}>;
#endif
#if 0
					panel_8 = <&${panel_name_8}>;
#endif
#if 0
					panel_9 = <&${panel_name_9}>;
#endif
				};
			};
		};
	};
};


/* #include "../abc_common.dtsi" */                  /* From abc_common.py */
&smd {
	abc_hub {
		compatible = "samsung,abc_hub";
		status = "okay";
		bootc {
			bootc,time_spec_user = <100000>; /* user binary user build */
			bootc,time_spec_eng = <150000>; /* user binary eng build */
			bootc,time_spec_fac = <100000>; /* factory binary */
		};
	};
};

/* #include "../ap_slsi_s5e8855.dtsi" */             /* From ap_slsi_s5e8855.py */
#include <dt-bindings/clock/s5e8855.h>
#include <dt-bindings/interrupt-controller/s5e8855.h>
#include "../mx8855-pmic.dtsi"

/* #include "../usb_notifier.dtsi" */                /* From usb_notifier.py */

&smd {
	usb_notifier {
		compatible = "samsung,usb-notifier";
		udc = <&udc>;
		status = "okay";
		disable_host_wakelock;
		disable_device_wakelock;
#if 0
		support_reverse_bypass_en;
#endif
	};
};


/* #include "../sec_auth_ds28e30.dtsi" */            /* From sec_auth_ds28e30.py */
&smd {
	sec_auth_ds28e30: sec-auth-ds28e30 {
			status = "okay";
			compatible = "samsung,sec_auth_ds28e30";
			/* read bit out low loop count , write bit out low loop count for main battery*/
			ds28e30,rw_out_low_loop_cnt = <3 3>;
			ds28e30,read_bit_vamm_cnt = <6>;
			/* read bit out low loop count , write bit out low loop count for sub battery*/
			ds28e30,rw_out_low_loop_cnt2 = <3 3>;
			ds28e30,read_bit_vamm_cnt2 = <6>;
#if 1
			sec_auth_ds28e30,swi_gpio = <
				SEC_GPIO_REF(AP,gpm10,gpm10,0) 0 /* SWI_GPIO */
#if 0
				SEC_GPIO_REF(${swi_gpio_2}) 0 /* SWI_GPIO_2 */
#endif
			>;
#endif
			};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/battery_auth/ds28e30/a56x/sec_auth_ds28e30.dtsi */
#if 1
&pinctrl_1 {
		sec_auth_gpio_init: sec_auth_gpio_init {
			GPIO_CONFIG_PUD(AP,gpm10,gpm10,0, FUNC_OUTPUT_HIGH, PULL_NONE);
		};
		sec_auth_gpio_sleep: sec_auth_gpio_sleep {
			GPIO_CONFIG_PUD(AP,gpm10,gpm10,0, FUNC_OUTPUT_HIGH, PULL_NONE);
		};
		sec_auth_gpio_pullup: sec_auth_gpio_pullup {
			GPIO_CONFIG_PUD(AP,gpm10,gpm10,0, FUNC_OUTPUT_HIGH, PULL_UP);
		};
	};
#endif

#if 1
&pinctrl_0 {
		sec_auth_gpio_pulldown: sec_auth_gpio_pulldown {
			GPIO_CONFIG_PUD(AP,gpc9,gpc9,0, FUNC_OUTPUT_LOW, PULL_DOWN);
		};
	};
#endif

&smd {
	sec_auth_ds28e30: sec-auth-ds28e30 {
		status = "okay";
		compatible = "samsung,sec_auth_ds28e30";
#if 1
		/* SWI_GPIO */
		ds28e30,swi_gpio = <SEC_GPIO_REF(AP,gpm10,gpm10,0) 0 >;
		/* s5e8855.dts (gpm10[0])--> Change according to AP and GPIO */
		ds28e30,base_phys_addr = <0x12030000 0x1000>;
		/* Control register, Data register --> Change according to AP and GPIO */
		ds28e30,offset = <0x0140 0x0144>;
		/* Control bit is 0th , Data bit is 0th --> Change according to AP and GPIO */
		ds28e30,bit_pos = <0 0>;
		/* Set CPU mask */
		ds28e30,cpu_start = <4>;
		ds28e30,cpu_end = <6>;
#if 1
		/*EUR_DETECTION_NODE*/
		ds28e30,eur_detection = <SEC_GPIO_REF(AP,gpc9,gpc9,0) 0 >;
		pinctrl-names = "init", "sleep", "swi_pullup", "pulldown";
		pinctrl-0 = <&sec_auth_gpio_init>;
		pinctrl-1 = <&sec_auth_gpio_sleep>;
		pinctrl-2 = <&sec_auth_gpio_pullup>;
		pinctrl-3 = <&sec_auth_gpio_pulldown>;
#else
		pinctrl-names = "init", "sleep", "swi_pullup";
		pinctrl-0 = <&sec_auth_gpio_init>;
		pinctrl-1 = <&sec_auth_gpio_sleep>;
		pinctrl-2 = <&sec_auth_gpio_pullup>;
#endif
#endif
	};
};

/* #include "../dio8018_v6_6.dtsi" */                /* From dio8018_v6_6.py */
&pinctrl_0 {
	dio8018_0_irq: dio8018_0_irq {
		GPIO_CONFIG_PUD(AP,gpa0,gpa0,0, FUNC_INPUT, PULL_NONE);
	};
};

&pinctrl_0 {
	dio8018_0_hw_reset: dio8018_0_hw_reset {
		GPIO_CONFIG_PUD(AP,gpa1,gpa1,4, FUNC_OUTPUT_LOW, PULL_NONE);
	};
};

&hsi2c_24 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	dio8018_0_pmic: dio8018_pmic@35{
		compatible = "dioo,dio8018pmic";
		reg = <0x35>;
		dio8018,wakeup;
		pinctrl-names = "default";
		pinctrl-0 = <&dio8018_0_irq>;
		dio8018,dio8018_int = <SEC_GPIO_REF(AP,gpa0,gpa0,0) 0>;
		dio8018,dio8018_int_level = <0>;
		dio8018,dio8018_int_outmode = <1>;
		dio8018,dio8018_reset = <SEC_GPIO_REF(AP,gpa1,gpa1,4) 0>;
		dio8018,need_sw_reset;

		regulators {
			reg_dio8018_0_ldo1: dio8018-ldo1 {
				regulator-name = "RCAM1_DVDD_1P1";
				regulator-min-microvolt = <1104000>;
				regulator-max-microvolt = <1104000>;
				
				regulator-min-microamp = <1300000>;regulator-max-microamp = <1800000>;
			};

			reg_dio8018_0_ldo2: dio8018-ldo2 {
				regulator-name = "FCAM_DVDD_1P05";
				regulator-min-microvolt = <1056000>;
				regulator-max-microvolt = <1104000>;
				
				regulator-min-microamp = <1300000>;regulator-max-microamp = <1800000>;
			};
	
			reg_dio8018_0_ldo3: dio8018-ldo3 {
				regulator-name = "FCAM_AVDD_2P8";
				regulator-min-microvolt = <2804000>;
				regulator-max-microvolt = <2804000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo4: dio8018-ldo4 {
				regulator-name = "RCAM1_AVDD_2P8";
				regulator-min-microvolt = <2804000>;
				regulator-max-microvolt = <2804000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo5: dio8018-ldo5 {
				regulator-name = "RCAM1_AFVDD_3P3";
				regulator-min-microvolt = <3300000>;
				regulator-max-microvolt = <3300000>;
				
				regulator-min-microamp = <650000>;regulator-max-microamp = <950000>;

			};

			reg_dio8018_0_ldo6: dio8018-ldo6 {
				regulator-name = "VDD_RCAM1_AVDD_1P8";
				regulator-min-microvolt = <1804000>;
				regulator-max-microvolt = <1804000>;
				
				regulator-min-microamp = <450000>;regulator-max-microamp = <650000>;
			};

			reg_dio8018_0_ldo7: dio8018-ldo7 {
				regulator-name = "CAM_OIS_VDD_3P3";
				regulator-min-microvolt = <3300000>;
				regulator-max-microvolt = <3300000>;
				
				regulator-min-microamp = <650000>;regulator-max-microamp = <950000>;
			};
		};
	};
};

/* #include "../s2mf301.dtsi" */                     /* From s2mf301.py */
&pinctrl_0 {
	if_pmic_irq: if_pmic_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,5, FUNC_INPUT_WAKEUP, PULL_UP, DRV_LV1);
	};
};

&pinctrl_0 {
	usbpd_irq: usbpd_irq {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,4, FUNC_INPUT_WAKEUP, PULL_UP, DRV_LV1);
	};
};

#if 0
&${usbpd_vbus_discharging_parent} {
	usbpd_vbus_discharging: usbpd_vbus_discharging {
		GPIO_CONFIG_PUD_DRV(${usbpd_vbus_discharging_gpio}, FUNC_OUTPUT_LOW, PULL_DOWN, DRV_LV1);
	};
};
#endif

#if 0
&${usbpd_vctrl_otg_parent} {
	usbpd_vctrl_otg: usbpd_vctrl_otg {
		GPIO_CONFIG_PUD_DRV(${usbpd_vctrl_otg_gpio}, FUNC_OUTPUT_LOW, PULL_DOWN, DRV_LV1);
	};
};
#endif

#if 0
&${pogo_dock_parent} {
	pogo_dock_int: pogo_dock_int {
		GPIO_CONFIG_PUD_DRV(${pogo_gpio}, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};
#endif

&hsi2c_27 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <400000>;
	samsung,i2c-max-bus-freq = <400000>;

	s2mf301: s2mf301@3A {
		status = "okay";
		compatible = "samsung,s2mf301mfd";
		reg = <0x3A>;
		pinctrl-names = "default";
		pinctrl-0 = <&if_pmic_irq>;
		s2mf301,irq-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,5) 1>;
		s2mf301,wakeup;
	};

	usbpd-s2mf301@3C {
		status = "okay";
		compatible = "s2mf301-usbpd";
		reg = <0x3C>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbpd_irq 
#if 0
						&usbpd_vbus_discharging
#endif
#if 0
						&usbpd_vctrl_otg
#endif
#if 0
						&pogo_dock_int
#endif
						>;
		usbpd,usbpd_int = <SEC_GPIO_REF(AP,gpa0,gpa0,4) 0>;
#if 0
		usbpd,vbus_discharging = <SEC_GPIO_REF(${usbpd_vbus_discharging_gpio}) 0>;
#endif
#if 0
		usbpd,vctrl_otg = <SEC_GPIO_REF(${usbpd_vctrl_otg_gpio}) 0>;
#endif
#if 0
		pogo_dock_int = <SEC_GPIO_REF(${pogo_gpio}) 0>;
#endif
#if 0
		vconn-en;
#endif
		pdic-manager {
			/* sink */
			pdic,max_power = <5000>;
			pdic_op_power = <2500>;
			pdic_max_voltage = <6000>;
			pdic_max_current = <2000>;
			pdic,min_current = <500>;

			pdic,giveback = <0>;
			pdic,usb_com_capable = <1>;
			pdic,no_usb_suspend = <1>;

			/* source */
			source,max_voltage = <5000>;
			source,min_voltage = <4000>;
			source,max_power = <2500>;

			/* sink cap */
			sink,capable_max_voltage = <5000>;
		};
	};
};


/* #include "../pmic_S2MPU16.dtsi" */                /* From pmic_S2MPU16.py */
#if 0 && 0
&s_l1_reg {
	regulator-name = "vdd_ldo1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l2_reg {
	regulator-name = "vdd_ldo2";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l3_reg {
	regulator-name = "vdd_ldo3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l4_reg {
	regulator-name = "vdd_ldo4";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l5_reg {
	regulator-name = "vdd_ldo5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l6_reg {
	regulator-name = "vdd_ldo6";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l7_reg {
	regulator-name = "vdd_ldo7";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l8_reg {
	regulator-name = "vdd_ldo8";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l9_reg {
	regulator-name = "vdd_ldo9";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l10_reg {
	regulator-name = "vdd_ldo10";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l11_reg {
	regulator-name = "vdd_ldo11";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l12_reg {
	regulator-name = "vdd_ldo12";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 3000000 && 3000000
&s_l13_reg {
	regulator-name = "vdd_ldo13";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	/delete-property/ regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&s_l14_reg {
	regulator-name = "vdd_ldo14";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&s_l15_reg {
	regulator-name = "vdd_ldo15";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

/* #include "../vibrator_aw8624x.dtsi" */            /* From vibrator_aw8624x.py */
#define VIB_CONNECTED_AP_slsi

&pinctrl_0 {
	motor_int_default: motor-int {
		GPIO_CONFIG_PUD(AP,gpc2,gpc2,0, FUNC_INPUT_WAKEUP, PULL_UP);
	};
};

&pinctrl_1 {
	motor_rst_default: motor-rst {
		GPIO_CONFIG_PUD_DRV(AP,gpm12,gpm12,0, FUNC_OUTPUT, PULL_NONE, DRV_LV1);
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
	};
};

#if 0
&${vib_boost_en_gpio_parent} {
	vib_power_default: vib_power_default {
		GPIO_CONFIG(${vib_boost_en_gpio}, FUNC_OUTPUT_HIGH);
	};

	vib_power_sleep: vib_power_sleep {
		GPIO_CONFIG(${vib_boost_en_gpio}, FUNC_OUTPUT_LOW);
	};
};
#endif

&hsi2c_20 {
	status = "ok";
	i2c-scl-hz = <400000>;
	aw8624x: aw8624x_haptic@58 {
		reg = <0x58>;
		samsung,max_level_gain = <0x80>;	/* max level gain */
#if 1
		samsung,f0-tracking;
		samsung,f0-tracking-offset = <4>;
#endif
		compatible = "awinic,aw8624x_haptic";
#if 0
		pinctrl-names = "default", "sleep";
		pinctrl-0 = <&motor_int_default &motor_rst_default &vib_power_default>;
		pinctrl-1 = <&vib_power_sleep>;
#else
		pinctrl-names = "default";
		pinctrl-0 = <&motor_int_default &motor_rst_default>;
#endif

		reset-gpio = <SEC_GPIO_REF(AP,gpm12,gpm12,0) 0>;
		irq-gpio = <SEC_GPIO_REF(AP,gpc2,gpc2,0) 0>;

		/* LRA parameters */
		vib_lra_vrms = < 900 >;		/* Motor rated voltage, mV */

		/* cont mode parameters */
		vib_d2s_gain = < 0x06 >;		/* brake gain based on LRA */
		vib_f0_d2s_gain = < 0x01 >;		/* f0 brake gain based on LRA */
		vib_cont_brk_gain = < 0x08 >;		/* brake gain(fine-tuning, mostly keep default) */
		vib_cont_brk_time = < 0x06 >;		/* half cycle number based on LRA */
		vib_cont_drv1_lvl = < 0x7F >;		/* overdrive voltage, keep default */
		vib_cont_drv2_lvl = < 0x23 >;		/* overdrive voltage, keep default */
		vib_cont_drv1_time = < 0x04 >;		/* half cycle number of overdrive, mostly keep default */
		vib_cont_drv2_time = < 0x14 >;		/* half cycle number of rms drive based on LRA */
		vib_cont_track_margin = < 0x0F >;	/* track margin, mostly keep default */

		vib_adjust_f0_min = < 1696 >;		/* adjust the f0 lower limit */
		vib_adjust_f0_max = < 1744 >;		/* adjust the f0 upper limit */
		vib_f0_cali_percen = < 15 >;		/* f0 calibration range 15% */
		/* vib_is_enabled_smart_loop; */
		vib_is_enabled_inter_brake;
		vib_is_enabled_auto_brk;
		status = "okay";
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/vibrator/VINCE/awinic/aw8624x_v9/vibrator_aw8624x_slsi.a56x.dtsi */
&aw8624x {
	/* LRA parameters */
	vib_f0_pre = < 1700 >;			/* 10 * F0 of LRA */
};


/* #include "../ptn3222.dtsi" */                     /* From ptn3222.py */
/*
 * Copyright (c) 2023 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&hsi2c_29 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	ptn3222-repeater@4F {
		compatible = "ptn3222-repeater";
		reg = <0x4F>;
		status = "okay";
		repeater_tune_param {
			repeater_tune_cnt = /bits/ 8 <0x5>;
			repeater_tune1 {
				tune_name = "usb2_rx_control";
				tune_value = /bits/ 8 <0x06 0x10>;
			};
			repeater_tune2 {
				tune_name = "usb2_tx_control1";
				tune_value = /bits/ 8 <0x07 0x22>;
			};
			repeater_tune3 {
				tune_name = "usb2_tx_control2";
				tune_value = /bits/ 8 <0x08 0x64>;
			};
			repeater_tune4 {
				tune_name = "usb2_termination";
				tune_value = /bits/ 8 <0x09 0x04>;
			};
			repeater_tune5 {
				tune_name = "usb2_disconnect_threshold";
				tune_value = /bits/ 8 <0x0a 0x01>;
			};
			repeater_tune6 {
				tune_name = "squelch_delay_control";
				tune_value = /bits/ 8 <0x17 0x5d>;
			};
			repeater_tune7 {
				tune_name = "RSV";
				tune_value = /bits/ 8 <0xff 0xff>;
			};
			repeater_tune8 {
				tune_name = "RSV";
				tune_value = /bits/ 8 <0xff 0xff>;
			};
		};
	};
};


/* #include "../sec_auth_sle956681.dtsi" */          /* From sec_auth_sle956681.py */
&smd {
	sec_auth_sle956681: sec-auth-sle956681 {
			status = "okay";
			compatible = "samsung,sec_auth_sle956681";

			authon,power_mode = "indirect";
			//authon,power_mode = "direct";

#if 1
			authon,1tau_value = <60>;
			authon,3tau_value = <180>;
			authon,5tau_value = <300>;
			authon,response_timeout_value = <1530>;
			authon,swi_gpio = <
				SEC_GPIO_REF(AP,gpm10,gpm10,0) 0 /* SWI_GPIO */
#if 0
				SEC_GPIO_REF(${swi_gpio_2}) 0 /* SWI_GPIO_2 */
#endif
				>;
#endif
#if 0
			authon,1tau_value2 = <60>;
			authon,3tau_value2 = <180>;
			authon,5tau_value2 = <300>;
#endif
			};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/battery_auth/sle956681/a56x/sec_auth_sle956681.dtsi */
#if 1
&pinctrl_0 {
		sec_auth_gpio_pull_down: sec_auth_gpio_pull_down {
			GPIO_CONFIG_PUD(AP,gpc9,gpc9,0, FUNC_OUTPUT_LOW, PULL_DOWN);
		};
	};
#endif

#if 1
&pinctrl_1 {
	sec_auth_gpio_pull_up: sec_auth_gpio_pull_up {
		GPIO_CONFIG_PUD(AP,gpm10,gpm10,0, FUNC_OUTPUT_HIGH, PULL_UP);
	};
};
#endif

&sec_auth_sle956681 {
	authon,1tau_value = <60>;
	authon,3tau_value = <180>;
	authon,5tau_value = <300>;
	authon,response_timeout_value = <4500>;
#if 1
	/*EUR_DETECTION_NODE*/
	authon,eur_detection = <SEC_GPIO_REF(AP,gpc9,gpc9,0) 0 >;
	pinctrl-names = "swi_pullup", "pull_down";
	pinctrl-0 = <&sec_auth_gpio_pull_up>;
	pinctrl-1 = <&sec_auth_gpio_pull_down>;
#else
	pinctrl-names = "swi_pullup";
	pinctrl-0 = <&sec_auth_gpio_pull_up>;
#endif
};




/* #include "../pmic_S2MPU15.dtsi" */                /* From pmic_S2MPU15.py */
#if 0 && 0
&l1_reg {
	regulator-name = "vdd_ldo1";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 3300000 && 3300000
&l2_reg {
	regulator-name = "vdd_ldo2";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	 
	/delete-property/ regulator-always-on;/delete-property/ regulator-boot-on;
};
#endif

#if 0 && 0
&l3_reg {
	regulator-name = "vdd_ldo3";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1600000 && 1950000
&l4_reg {
	regulator-name = "vdd_ldo4";
	regulator-min-microvolt = <1600000>;
	regulator-max-microvolt = <1950000>;
	 
	/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l5_reg {
	regulator-name = "vdd_ldo5";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 3375000
&l6_reg {
	regulator-name = "vdd_ldo6";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <3375000>;
	 
	/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l7_reg {
	regulator-name = "vdd_ldo7";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l8_reg {
	regulator-name = "vdd_ldo8";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l9_reg {
	regulator-name = "vdd_ldo9";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l10_reg {
	regulator-name = "vdd_ldo10";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l11_reg {
	regulator-name = "vdd_ldo11";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l12_reg {
	regulator-name = "vdd_ldo12";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l13_reg {
	regulator-name = "vdd_ldo13";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l14_reg {
	regulator-name = "vdd_ldo14";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l15_reg {
	regulator-name = "vdd_ldo15";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l16_reg {
	regulator-name = "vdd_ldo16";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l17_reg {
	regulator-name = "vdd_ldo17";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l18_reg {
	regulator-name = "vdd_ldo18";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l19_reg {
	regulator-name = "vdd_ldo19";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l20_reg {
	regulator-name = "vdd_ldo20";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l21_reg {
	regulator-name = "vdd_ldo21";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l22_reg {
	regulator-name = "vdd_ldo22";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 400000 && 1300000
&l23_reg {
	regulator-name = "vdd_ldo23";
	regulator-min-microvolt = <400000>;
	regulator-max-microvolt = <1300000>;
	 
	/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l24_reg {
	regulator-name = "vdd_ldo24";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l25_reg {
	regulator-name = "vdd_ldo25";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 1800000 && 1800000
&l26_reg {
	regulator-name = "vdd_ldo26";
	regulator-min-microvolt = <1800000>;
	regulator-max-microvolt = <1800000>;
	 
	
};
#endif

#if 0 && 0
&l27_reg {
	regulator-name = "vdd_ldo27";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l28_reg {
	regulator-name = "vdd_ldo28";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l29_reg {
	regulator-name = "vdd_ldo29";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l30_reg {
	regulator-name = "vdd_ldo30";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l31_reg {
	regulator-name = "vdd_ldo31";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 3000000 && 3000000
&l32_reg {
	regulator-name = "vdd_ldo32";
	regulator-min-microvolt = <3000000>;
	regulator-max-microvolt = <3000000>;
	 
	regulator-boot-on;/delete-property/ regulator-always-on;
};
#endif

#if 0 && 0
&l33_reg {
	regulator-name = "vdd_ldo33";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l34_reg {
	regulator-name = "vdd_ldo34";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif

#if 0 && 0
&l35_reg {
	regulator-name = "vdd_ldo35";
	regulator-min-microvolt = <0>;
	regulator-max-microvolt = <0>;
	 
	
};
#endif


/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/pmic/slsi/S2MPU15/dts/pmic_S2MPU15.a56x.dtsi */
&b_sr4_reg {
	regulator-min-microvolt = <1962500>;
	regulator-max-microvolt = <1962500>;
};

/delete-node/ &l19_reg;

/* #include "../sensorhub_s5e8855.dtsi" */           /* From sensorhub_s5e8855.py */
&contexthub_0 {
	multi-os = "disabled";
};


/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				compatible = "shub";
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/sensorhub/lsi/s5e8855/dts/sensorhub_s5e8855.a56x.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				acc-icm42632m-position = <2>;
				mag-ak09918c-position = <7>;
				mag-ak09918c-array = /bits/ 8 <128 90 157 111 176 43 1 139 202 52 186 232 207 179 254 179 2 224 80 138 188 4 3 52 12 5 175>;
				mag-ak09918c-cover-array = /bits/ 8 <0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0>;
				light-position = /bits/ 32 <27 79 4 79 3 1>;
				brightness-array-len = <11>;
				brightness-array = /bits/ 32 <19 48 54 58 63 67 70 73 75 77 100>;
			};
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/sensorhub/lsi/s5e8855/dts/sensorhub_s5e8855.a56x.01.dtsi */
/ {
	fragment@model {
		target-path = "/";
		__overlay__ {
			shub {
				acc-icm42632m-position = <6>;
			};
		};
	};
};
/* #include "../nu2111a_charger.dtsi" */             /* From nu2111a_charger.py */
&hsi2c_27 {
	status = "okay";

	nu2111a_charger: nu2111a@6e {
		compatible = "nuvolta,nu2111a";
		reg = <0x6e>;
#if 1
		nu2111a,sub_i2c-bus = <&hsi2c_22>;
#endif
		nu2111a,vbat-reg = <4450000>;
		nu2111a,input-current-limit = <3000000>; /* 3.0A */
		nu2111a,charging-current = <6000000>; /* 6.0A */
		nu2111a,topoff-current = <400000>; /* 400mA */
		nu2111a,chg-mode = <1>; /* 2:1 direct charging mode */
		nu2111a,cv-polling = <2000>; /* 2000ms */
		nu2111a,step1-cv=<4200000>; /* 4200mV */
		nu2111a,wd-tmr=<0x04>; /* 5s */
		/* WDT enabled */
		//nu2111a,wd-dis;
	};
};

#if 1
&hsi2c_22 {
	status = "okay";
};
#endif

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/charger/nu2111a/nu2111a_charger.a56x.dtsi */
&nu2111a_charger {
	nu2111a,use-dc-vbat;
};

/* #include "../regulator-fixe-2.dtsi" */            /* From regulator-fixed.py */
/* 
 * This pinctrl code is only for PULL state change.
 * IN-OUT setting is set to OUTPUT at fixed-regulator probe.
 */

&pinctrl_0 {
        ldo_gpio2: ldo_gpio2 {
#if 1
		GPIO_CONFIG_PUD(AP,gpc10,gpc10,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#else
		GPIO_CONFIG_PUD(AP,gpc10,gpc10,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#endif
#if 0
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
#endif
#if 1
		
#endif
        };
};

&smd {
	fixed_regulator2: fixed_regulator@2 {
		compatible = "regulator-fixed";
#if 1
		regulator-name = "fixed_regulator${#}";
#else
		regulator-name = "fixed_regulator2";
#endif
		gpio = <SEC_GPIO_REF(AP,gpc10,gpc10,0) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ldo_gpio2>;
		enable-active-high;
	};
};


/* #include "../regulator-fixe-1.dtsi" */            /* From regulator-fixed.py */
/* 
 * This pinctrl code is only for PULL state change.
 * IN-OUT setting is set to OUTPUT at fixed-regulator probe.
 */

&pinctrl_3 {
        ldo_gpio1: ldo_gpio1 {
#if 1
		GPIO_CONFIG_PUD(AP,gpp1,gpp1,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#else
		GPIO_CONFIG_PUD(AP,gpp1,gpp1,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#endif
#if 1
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
#endif
#if 1
		
#endif
        };
};

&smd {
	fixed_regulator1: fixed_regulator@1 {
		compatible = "regulator-fixed";
#if 1
		regulator-name = "fixed_regulator${#}";
#else
		regulator-name = "fixed_regulator1";
#endif
		gpio = <SEC_GPIO_REF(AP,gpp1,gpp1,0) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ldo_gpio1>;
		enable-active-high;
	};
};


/* #include "../regulator-fixed.dtsi" */             /* From regulator-fixed.py */
/* 
 * This pinctrl code is only for PULL state change.
 * IN-OUT setting is set to OUTPUT at fixed-regulator probe.
 */

&pinctrl_1 {
        ldo_gpio0: ldo_gpio0 {
#if 1
		GPIO_CONFIG_PUD(AP,gpm3,gpm3,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#else
		GPIO_CONFIG_PUD(AP,gpm3,gpm3,0, FUNC_OUTPUT_HIGH, PULL_NONE);
#endif
#if 0
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <0>;
#endif
#if 1
		
#endif
        };
};

&smd {
	fixed_regulator0: fixed_regulator@0 {
		compatible = "regulator-fixed";
#if 1
		regulator-name = "fixed_regulator${#}";
#else
		regulator-name = "fixed_regulator0";
#endif
		gpio = <SEC_GPIO_REF(AP,gpm3,gpm3,0) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ldo_gpio0>;
		enable-active-high;
	};
};


/* #include "../s2mf301_muic.dtsi" */                /* From s2mf301_muic.py */
&smd {
	muic {
		new_factory;
		dcd_timeout;
#if 0
		uses_sido_vbus_switch;
#endif
#if 0
		disable_afc;
#endif
	};
};

/* #include "../s2mf301_fuelgauge.dtsi" */           /* From s2mf301_fuelgauge.py */
/*
 * s2mf301 battery device tree common
 *
 * Copyright (c) 2022 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	s2mf301_fuelgauge: s2mf301-fuelgauge {
		status = "okay";
		fuelgauge,capacity_full = <5000>;
		fuelgauge,low_voltage_limit_lowtemp = <3100>;
		fuelgauge,fuel_alert_soc = <1>;
		fuelgauge,capacity_max = <1000>;
		fuelgauge,capacity_max_margin = <200>;
		fuelgauge,capacity_min = <0>;
		fuelgauge,capacity_calculation_type = <28>;
		fuelgauge,use_external_temp;
#if 0
		fuelgauge,bat_id_gpio = <
				SEC_GPIO_REF(${bat_id_single_gpio}) 0  /* BAT_ID_1 */
				>;
#elif 1
		fuelgauge,bat_id_gpio = <
				SEC_GPIO_REF(PM,s2mpu16_gpio,gpio_s,1) 0  /* BAT_ID_2 */
				SEC_GPIO_REF(PM,s2mpu16_gpio,gpio_s,4) 0  /* BAT_ID_1 */
				>;
#endif
	};
};

&smd {
	battery {
		battery,fgsrc_switch_name = "s2mf301-fuelgauge"; /* Fuelgauge voltage source */
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/fuelgauge/s2mf301/a56x/s2mf301_fuelgauge.dtsi */
/*
 * s2mf301 battery device tree common
 *
 * Copyright (c) 2023 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&smd {
	s2mf301_fuelgauge: s2mf301-fuelgauge {
		status = "okay";
		fuelgauge,capacity_full = <5000>;
		fuelgauge,low_voltage_limit_lowtemp = <3100>;
		fuelgauge,low_voltage_limit = <3350>;
		fuelgauge,fuel_alert_soc = <1>;
		fuelgauge,capacity_max = <1000>;
		fuelgauge,capacity_max_margin = <200>;
		fuelgauge,capacity_min = <0>;
		fuelgauge,capacity_calculation_type = <28>;
		fuelgauge,use_external_temp;
		/* zadj data [0x12] [0x13] [0x15] */
		fuelgauge3,zadj_data = <
			/* zadj data for 4.48 */
			2 0 1
			/* zadj data for 4.46 */
			2 0 1
			/* zadj data for 4.44 */
			2 0 1
			/* zadj data for 4.42 */
			2 0 1
			/* zadj data for 4.37 */
			2 0 1
			>;
		fuelgauge2,zadj_data = <
			/* zadj data for 4.48 */
			2 0 1
			/* zadj data for 4.46 */
			2 0 1
			/* zadj data for 4.44 */
			2 0 1
			/* zadj data for 4.42 */
			2 0 1
			/* zadj data for 4.37 */
			2 0 1
			>;
		fuelgauge1,zadj_data = <
			/* zadj data for 4.48 */
			0 2 0
			/* zadj data for 4.46 */
			0 2 0
			/* zadj data for 4.44 */
			0 2 0
			/* zadj data for 4.42 */
			0 2 0
			/* zadj data for 4.37 */
			0 2 0
			>;
		fuelgauge0,zadj_data = <
			/* zadj data for 4.48 */
			2 0 1
			/* zadj data for 4.46 */
			2 0 1
			/* zadj data for 4.44 */
			2 0 1
			/* zadj data for 4.42 */
			2 0 1
			/* zadj data for 4.37 */
			2 0 1
			>;
#if 1
		fuelgauge,bat_id_gpio = <
				SEC_GPIO_REF(PM,s2mpu16_gpio,gpio_s,1) 0  /* BAT_ID_2 */
				SEC_GPIO_REF(PM,s2mpu16_gpio,gpio_s,4) 0  /* BAT_ID_1 */
				>;
		fuelgauge,bat_id_cutoff_level = <3300 3400 3300 3300>;
#endif
	};
};

&smd {
	battery {
		battery,fgsrc_switch_name = "s2mf301-fuelgauge"; /* Fuelgauge voltage source */
	};
};

&smd {
	s2mf301_battery_params: battery_params {
	/*
	 * BAT_ID_1/BAT_ID_2
	 * 00: ATL, 01: ATL_safe
	 * 10: SDI, 11: ATL
	 */
		battery,id = <3>;

	/* 11: ATL */
		battery3,battery_data = <
		/***** battery data for 4.48 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 0 8 154 7 52 7
			206 6 104 6 2 6 156 5 54 5
			208 4 106 4 4 4 158 3 56 3
			210 2 108 2 6 2 160 1 57 1
			212 0 110 0 7 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0xf8 0x51 0xb8 0xb /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xf8 0x51 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xf9 0x51 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10000 9502 9003 8505 8007 7509 7011 6513 6014 5516
			5018 4520  4022 3523 3025 2527 2029 1531 1033 535
			37 (-53)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.46 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 31 8 183 7 80 7
			232 6 129 6 25 6 178 5 74 5
			226 4 123 4 19 4 172 3 68 3
			221 2 117 2 13 2 166 1 62 1
			215 0 111 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x30 0x4d 0x82 0xd /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x30 0x4d /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x31 0x4d /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10152 9646 9140 8634 8129 7623 7117 6611 6105 5600
			5094 4588 4083 3577 3071 2566 2060 1554 1048 543
			37 (-53)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.44 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 72 8 222 7 116 7
			11 7 161 6 56 6 206 5 101 5
			251 4 145 4 40 4 190 3 85 3
			235 2 129 2 24 2 174 1 68 1
			219 0 113 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0xb4 0x4b 0x3f 0xd /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xb4 0x4b /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xb5 0x4b /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10350 9835 9319 8803 8288 7772 7257 6741 6225 5710
			5194 4678 4163 3647 3131 2616 2100 1584 1069 554
			38 (-54)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.42 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 114 8 6 8 155 7
			47 7 195 6 88 6 236 5 128 5
			20 5 169 4 61 4 209 3 102 3
			250 2 142 2 34 2 183 1 75 1
			223 0 116 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x3c 0x4a 0xfd 0xc  /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x3c 0x4a /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x3d 0x4a /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10557 10031 9505 8979 8454 7927 7402 6876 6349 5824
			5298 4771 4246 3720 3194 2668 2142 1616 1090 565
			39 (-55)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.37 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 227 8 113 8 0 8
			143 7 29 7 172 6 59 6 201 5
			88 5 231 4 117 4 4 4 147 3
			33 3 176 2 63 2 206 1 92 1
			235 0 122 0 8 0 244 15

			/* battery,battery_table4 */
			13 13 13 13 13 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x90 0x46 0x59 0xc /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x90 0x46 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x91 0x46 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			11106 10553 9999 9446 8893 8340 7787 7233 6679 6127
			5573 5019 4466 3913 3360 2807 2254 1700 1147 594
			41 (-58)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			>;
	/* 10: SDI */
		battery2,battery_data = <
			/***** battery data for 4.48 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 0 8 154 7 52 7
			206 6 104 6 2 6 156 5 54 5
			208 4 106 4 4 4 158 3 56 3
			210 2 108 2 6 2 160 1 57 1
			212 0 110 0 7 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0xf8 0x51 0xb8 0xb /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xf8 0x51 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xf9 0x51 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10000 9502 9003 8505 8007 7509 7011 6513 6014 5516
			5018 4520  4022 3523 3025 2527 2029 1531 1033 535
			37 (-53)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.46 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 31 8 183 7 80 7
			232 6 129 6 25 6 178 5 74 5
			226 4 123 4 19 4 172 3 68 3
			221 2 117 2 13 2 166 1 62 1
			215 0 111 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x30 0x4d 0x82 0xd /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x30 0x4d /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x31 0x4d /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10152 9646 9140 8634 8129 7623 7117 6611 6105 5600
			5094 4588 4083 3577 3071 2566 2060 1554 1048 543
			37 (-53)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.44 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 72 8 222 7 116 7
			11 7 161 6 56 6 206 5 101 5
			251 4 145 4 40 4 190 3 85 3
			235 2 129 2 24 2 174 1 68 1
			219 0 113 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0xb4 0x4b 0x3f 0xd /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xb4 0x4b /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xb5 0x4b /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10350 9835 9319 8803 8288 7772 7257 6741 6225 5710
			5194 4678 4163 3647 3131 2616 2100 1584 1069 554
			38 (-54)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.42 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 114 8 6 8 155 7
			47 7 195 6 88 6 236 5 128 5
			20 5 169 4 61 4 209 3 102 3
			250 2 142 2 34 2 183 1 75 1
			223 0 116 0 8 0 245 15

			/* battery,battery_table4 */
			13 13 13 13 26 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x3c 0x4a 0xfd 0xc  /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x3c 0x4a /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x3d 0x4a /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10557 10031 9505 8979 8454 7927 7402 6876 6349 5824
			5298 4771 4246 3720 3194 2668 2142 1616 1090 565
			39 (-55)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			/***** battery data for 4.37 *****/
			/* battery,battery_table3 */
			151 11 40 11 191 10 73 10 203 9
			79 9 216 8 107 8 8 8 151 7
			35 7 226 6 173 6 131 6 96 6
			59 6 7 6 207 5 142 5 116 5
			172 2 231 0 227 8 113 8 0 8
			143 7 29 7 172 6 59 6 201 5
			88 5 231 4 117 4 4 4 147 3
			33 3 176 2 63 2 206 1 92 1
			235 0 122 0 8 0 244 15

			/* battery,battery_table4 */
			13 13 13 13 13 26 25 25 25 26
			26 26 26 26 27 27 27 27 27 27
			28 154

			/* battery,batcap */
			0x90 0x46 0x59 0xc /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x90 0x46 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x91 0x46 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			11106 10553 9999 9446 8893 8340 7787 7233 6679 6127
			5573 5019 4466 3913 3360 2807 2254 1700 1147 594
			41 (-58)

			/* battery,ocv_arr_val */
			44486 43943 43431 42857 42242 41634 41056 40521 40038 39486
			38922 38602 38346 38140 37970 37786 37532 37259 36945 36817
			33341 31126

			/* battery,rRS_CC0 */
			0x13 /* [0x5C] */

			>;
		/* 01: ATL_safe */
		battery1,battery_data = <
			/***** battery data for 4.48 *****/
			/* battery,battery_table3 */
			152 11 33 11 185 10 67 10 197 9
			73 9 210 8 101 8 3 8 157 7
			33 7 222 6 170 6 129 6 95 6
			59 6 10 6 218 5 146 5 125 5
			168 3 24 2 0 8 154 7 52 7
			206 6 105 6 3 6 157 5 55 5
			209 4 107 4 5 4 160 3 58 3
			212 2 110 2 8 2 162 1 60 1
			214 0 112 0 11 0 239 15

			/* battery,battery_table4 */
			14 14 14 13 25 25 25 25 25 25
			25 25 25 25 25 25 25 26 26 27
			28 90

			/* battery,batcap */
			0x3f 0x51 0x37 0xe /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x3f 0x51 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x3f 0x51 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10000 9503 9005 8508 8011 7513 7016 6518 6021 5524
			5026 4529 4031 3534 3036 2539 2042 1544 1047 549
			52 (-85)

			/* battery,ocv_arr_val */
			44493 43913 43402 42827 42212 41605 41027 40494 40015 39519
			38909 38586 38332 38128 37966 37789 37550 37313 36961 36859
			34572 32617

			/* battery,rRS_CC0 */
			0x12 /* [0x5C] */

			/***** battery data for 4.46 *****/
			/* battery,battery_table3 */
			152 11 33 11 185 10 67 10 197 9
			73 9 210 8 101 8 3 8 157 7
			33 7 222 6 170 6 129 6 95 6
			59 6 10 6 218 5 146 5 125 5
			168 3 24 2 28 8 181 7 77 7
			230 6 127 6 24 6 176 5 73 5
			226 4 122 4 19 4 172 3 69 3
			221 2 118 2 15 2 168 1 64 1
			217 0 114 0 11 0 238 15

			/* battery,battery_table4 */
			14 14 14 13 25 25 25 25 25 25
			25 25 25 25 25 25 25 26 26 27
			28 90

			/* battery,batcap */
			0x26 0x50 0x06 0xe /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x26 0x50 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x27 0x50 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10136 9632 9128 8623 8119 7615 7111 6607 6103 5598
			5094 4590 4086 3581 3077 2573 2069 1565 1061 556
			52 (-86)

			/* battery,ocv_arr_val */
			44493 43913 43402 42827 42212 41605 41027 40494 40015 39519
			38909 38586 38332 38128 37966 37789 37550 37313 36961 36859
			34572 32617

			/* battery,rRS_CC0 */
			0x12 /* [0x5C] */

			/***** battery data for 4.44 *****/
			/* battery,battery_table3 */
			152 11 33 11 185 10 67 10 197 9
			73 9 210 8 101 8 3 8 157 7
			33 7 222 6 170 6 129 6 95 6
			59 6 10 6 218 5 146 5 125 5
			168 3 24 2 62 8 213 7 108 7
			3 7 154 6 49 6 200 5 95 5
			246 4 141 4 36 4 187 3 83 3
			234 2 129 2 24 2 175 1 70 1
			221 0 116 0 11 0 238 15

			/* battery,battery_table4 */
			14 14 14 13 25 25 25 25 25 25
			25 25 25 25 25 25 25 26 26 27
			28 90

			/* battery,batcap */
			0xdb 0x4e 0xcc 0xd /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xdb 0x4e /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xdb 0x4e /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10303 9790 9278 8765 8253 7740 7228 6716 6203 5690
			5178 4665 4153 3641 3128 2615 2103 1590 1078 565
			53 (-88)

			/* battery,ocv_arr_val */
			44493 43913 43402 42827 42212 41605 41027 40494 40015 39519
			38909 38586 38332 38128 37966 37789 37550 37313 36961 36859
			34572 32617

			/* battery,rRS_CC0 */
			0x12 /* [0x5C] */

			/***** battery data for 4.42 *****/
			/* battery,battery_table3 */
			152 11 33 11 185 10 67 10 197 9
			73 9 210 8 101 8 3 8 157 7
			33 7 222 6 170 6 129 6 95 6
			59 6 10 6 218 5 146 5 125 5
			168 3 24 2 104 8 253 7 146 7
			39 7 188 6 81 6 230 5 123 5
			16 5 165 4 58 4 206 3 99 3
			248 2 141 2 34 2 183 1 76 1
			225 0 118 0 11 0 238 15

			/* battery,battery_table4 */
			14 14 14 13 25 25 25 25 25 25
			25 25 25 25 25 25 25 26 26 27
			28 90

			/* battery,batcap */
			0x52 0x4d 0x87 0xd  /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0x52 0x4d /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0x52 0x4d /* 0x90~0x91 */

			/* battery,soc_arr_val */
			10508 9985 9462 8940 8417 7894 7372 6849 6326 5804
			5281 4758 4235 3713 3190 2667 2145 1622 1100 577
			54 (-89)

			/* battery,ocv_arr_val */
			44493 43913 43402 42827 42212 41605 41027 40494 40015 39519
			38909 38586 38332 38128 37966 37789 37550 37313 36961 36859
			34572 32617

			/* battery,rRS_CC0 */
			0x12 /* [0x5C] */

			/***** battery data for 4.37 *****/
			/* battery,battery_table3 */
			152 11 33 11 185 10 67 10 197 9
			73 9 210 8 101 8 3 8 157 7
			33 7 222 6 170 6 129 6 95 6
			59 6 10 6 218 5 146 5 125 5
			168 3 24 2 212 8 99 8 243 7
			130 7 18 7 162 6 49 6 193 5
			80 5 224 4 111 4 255 3 143 3
			30 3 174 2 62 2 205 1 93 1
			236 0 124 0 12 0 237 15

			/* battery,battery_table4 */
			14 14 14 13 25 25 25 25 25 25
			25 25 25 25 25 25 25 26 26 27
			28 90

			/* battery,batcap */
			0xa5 0x49 0xe2 0xc /* [0x0E] [0x0F] [0x10] [0x11] */

			/* battery,designcap */
			0xa5 0x49 /* [0x86~0x87] */

			/* battery,batcap_ocv_new */
			0xa5 0x49 /* 0x90~0x91 */

			/* battery,soc_arr_val */
			11033 10484 9935 9386 8837 8289 7740 7191 6642 6093
			5544 4996 4447 3898 3349 2801 2252 1703 1154 605
			57 (-94)

			/* battery,ocv_arr_val */
			44493 43913 43402 42827 42212 41605 41027 40494 40015 39519
			38909 38586 38332 38128 37966 37789 37550 37313 36961 36859
			34572 32617

			/* battery,rRS_CC0 */
			0x12 /* [0x5C] */

			>;
	};
};

/* #include "../sec_thermistor-1.dtsi" */            /* From sec_thermistor.py */
&smd{
	sec_pa_thermistor: sec_thermistor@1 {
		compatible = "samsung,sec-thermistor";
		status = "okay";
		thermistor_name = "sec-pa-thermistor";
		id = <1>;

		io-channels = SEC_ADC(s2mpu15_gpadc,5);
		io-channel-names = "adc-pa-temp";
		io-channel-ranges;
	};
};

/* #include "../sec_thermistor.dtsi" */              /* From sec_thermistor.py */
&smd{
	sec_ap_thermistor: sec_thermistor@0 {
		compatible = "samsung,sec-thermistor";
		status = "okay";
		thermistor_name = "sec-ap-thermistor";
		id = <0>;

		io-channels = SEC_ADC(s2mpu15_gpadc,1);
		io-channel-names = "adc-ap-temp";
		io-channel-ranges;
	};
};

/* #include "../sec_thermistor-3.dtsi" */            /* From sec_thermistor.py */
&smd{
	sec_lp_thermistor: sec_thermistor@3 {
		compatible = "samsung,sec-thermistor";
		status = "okay";
		thermistor_name = "sec-lp-thermistor";
		id = <3>;

		io-channels = SEC_ADC(s2mpu15_gpadc,4);
		io-channel-names = "adc-lp-temp";
		io-channel-ranges;
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/sec_pm/sec_thermistor/dts/sec_thermistor_lsi.a56x.dtsi */
&sec_ap_thermistor {
	adc_array = <272 319 376 442 520 612 712 844 985 1136
		1323 1532 1765 1944 2147 2385 2618 2854 3090 3289
		3452 3596 3713>;
	temp_array = <900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)>;
};

&sec_lp_thermistor {
	adc_array = <273 321 378 444 521 612 714 844 984 1140
		1324 1534 1767 1948 2149 2388 2621 2855 3087 3287
		3450 3592 3713>;
	temp_array = <900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)>;
};

&sec_pa_thermistor {
	adc_array = <369 485 628 789 987 1220 1455 1687 1925 2127
		2309 2542 2754 2940 3095 3236 3369 3473 3564 3642
		3709 3765 3812>;
	temp_array = <(-200) (-150) (-100) (-50) 0 50 100 150 200 250
		300 350 400 450 500 550 600 650 700 750
		800 850 900>;
};

/* #include "../snvm_k250a.dtsi" */                  /* From snvm_k250a.py */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

&pinctrl_0 {
	snvm_i2c_on: snvm_i2c_on {
		samsung,pins = SEC_GPIO(AP,gpc13,gpc13,0), SEC_GPIO(AP,gpc14,gpc14,0);
		samsung,pin-function = <3>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <0>;
	};
	snvm_i2c_off: snvm_i2c_off {
		samsung,pins = SEC_GPIO(AP,gpc13,gpc13,0), SEC_GPIO(AP,gpc14,gpc14,0);
		samsung,pin-function = <0>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <1>;
	};
};

&hsi2c_28 {
	clock-frequency = <400000>;
#if 1	
	status = "disabled";
#else
	status = "okay";
#endif
	pinctrl-names = "default", "nvm_on","nvm_off";
	pinctrl-0 = <&snvm_i2c_off>;
	pinctrl-1 = <&snvm_i2c_on>;
	pinctrl-2 = <&snvm_i2c_off>;
	k250a@23 {
		compatible = "sec_k250a";
		1p8_pvdd-supply = <&fixed_regulator2>;
		reg = <0x23>;
	};
};

#if 1
/ {
	fragment@k250a_platform {
		target-path = "/";
		__overlay__ {
			k250a_platform {
				status = "ok";
				compatible = "sec_k250a_platform";
				1p8_pvdd-supply = <&fixed_regulator2>;
			};
		};
	};
};
#endif
/* #include "../display_common_oled_board.dtsi" */   /* From display_common_oled_board.py */
/*
 * Samsung Exynos SoC series Panel driver
 *
 * Copyright (c) 2020 Samsung Electronics Co., Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#if 1
#define ERR_FG_Disable
#endif

#if defined(ERR_FG_1)
#define ERR_FG_TRUE
#endif

#if 0
#define ADD_ID(lb) lb##${PANEL_DRV_ID}
#else
#define ADD_ID(lb) lb
#endif

&pinctrl_0 {
	ADD_ID(disp_rst_default): ADD_ID(disp-rst-default) {
		samsung,pins = SEC_GPIO(AP,gpc5,gpc5,0);
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};

#if 1
&pinctrl_0 {
	ADD_ID(disp_det_default): ADD_ID(disp_det_default) {
		GPIO_CONFIG_PUD(AP,gpc4,gpc4,0, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
&${err_fg_parent} {
	ADD_ID(err_fg_default): ADD_ID(err_fg_default) {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if defined(ERR_FG_Falling_edge)
&${err_fg_parent} {
	ADD_ID(err_fg_default): ADD_ID(err_fg_default) {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_UP);
	};
};
#endif

#if defined(ERR_FG_Falling_edge_pull_down)
&${err_fg_parent} {
	ADD_ID(err_fg_default): ADD_ID(err_fg_default) {
		GPIO_CONFIG_PUD(${err_fg_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 1
&pinctrl_0 {
	ADD_ID(conn_det_default): ADD_ID(conn_det_default) {
		samsung,pins = SEC_GPIO(AP,gpc3,gpc3,0);
		samsung,pin-funciton = <0>;			// IN
		samsung,pin-pud = <0>;				// NP
		samsung,pin-con-pdn = <2>;			// IN
		samsung,pin-pud-pdn = <0>;			// NP in sleep
	};
};
#endif
#if 0
&${disp_te_parent} {
	ADD_ID(disp_te_default): ADD_ID(disp_te_default) {
		samsung,pins = SEC_GPIO(${disp_te_gpio});
		samsung,pin-funciton = <0xf>;			// INT
		samsung,pin-pud = <1>;					// PD
		samsung,pin-con-pdn = <3>;				// PREV in sleep
		samsung,pin-pud-pdn = <0>;				// NP in sleep
	};
};
#endif
#if 1
&pinctrl_0 {
	ADD_ID(pcd_default): ADD_ID(pcd_default) {
		GPIO_CONFIG_PUD(AP,gpc6,gpc6,0, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 0
&${avdd_en_parent} {
	ADD_ID(avdd_en_default): ADD_ID(avdd_en_default) {
		samsung,pins = SEC_GPIO(${avdd_en_gpio});
		samsung,pin-function = <1>;	// OUT
		samsung,pin-pud = <0>;		// NP
		samsung,pin-con-pdn = <3>;	// PREV in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
};
#endif

#if 0
&${poc_spi_parent} {
	ADD_ID(poc_spi_sleep_state_np): ADD_ID(poc_spi_sleep_state_np) {
		samsung,pins = SEC_GPIO(${poc_spi_cs}), SEC_GPIO(${poc_spi_clk});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <0>;		// NP
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <0>;	// NP in sleep
	};
	ADD_ID(poc_spi_sleep_state_pd): ADD_ID(poc_spi_sleep_state_pd) {
		samsung,pins = SEC_GPIO(${poc_spi_mosi}), SEC_GPIO(${poc_spi_miso});
		samsung,pin-functions = <0>;	// GPIO
		samsung,pin-pud = <1>;		// PD
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <2>;	// INPUT in sleep
		samsung,pin-pud-pdn = <1>;	// PD in sleep
	};
};
#endif

#if 0
&${lcd_vendor_check_parent} {
	ADD_ID(lcd_vendor_check_default): ADD_ID(lcd_vendor_check_default) {
		GPIO_CONFIG_PUD(${lcd_vendor_check_gpio}, FUNC_INPUT, PULL_NONE);
	};
};
#endif

#if 0
&${rst_ready_parent} {
	ADD_ID(rst_ready_default): ADD_ID(rst_ready_default) {
		GPIO_CONFIG_PUD(${rst_ready_gpio}, FUNC_INPUT, PULL_DOWN);
	};
};
#endif

#if 1
&l32_reg {
	regulator-boot-on;
};
#endif

#if 1
&l22_reg {
	regulator-boot-on;
};
#endif

#if 0
&${ddr_vddr_reg} {
	regulator-boot-on;
};
#endif

/ {
	fragment@panel_drv {
		target-path = "/";
		__overlay__ {
#if 0
		panel_drv_${PANEL_DRV_ID}: panel_drv_${PANEL_DRV_ID} {
#else
		panel_drv_0: panel_drv_0 {
#endif
				pinctrl-names = "default";
				pinctrl-0 = <
							&ADD_ID(disp_rst_default)
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_Falling_edge) || defined(ERR_FG_TRUE) || defined(ERR_FG_Falling_edge_pull_down)
							&ADD_ID(err_fg_default)
#endif
#if 1
							&ADD_ID(disp_det_default)
#endif
#if 1
							&ADD_ID(conn_det_default)
#endif
#if 0
							&ADD_ID(disp_te_default)
#endif
#if 0
							&ADD_ID(avdd_en_default)
#endif
#if 0
							&ADD_ID(poc_spi_sleep_state_np)
							&ADD_ID(poc_spi_sleep_state_pd)
#endif
#if 0
							&ADD_ID(lcd_vendor_check_default)
#endif
#if 0
							&ADD_ID(rst_ready_default)
#endif
				>;

				gpios {
					ADD_ID(disp_reset): disp-reset {
						gpios = <SEC_GPIO_REF(AP,gpc5,gpc5,0) 1>;	/* ACTIVE_LOW */
						dir = <0>;  /* OUT */
						irq-type = <0x0>;   /* NONE */
					};
#if 1
					ADD_ID(disp_det): disp-det {
						gpios = <SEC_GPIO_REF(AP,gpc4,gpc4,0) 1>;  /* 0:OK, 1:NOK(active) */
						dir = <1>;  /* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
						irq-pend {
							reg = <0x0 0x15850A34 0x0>;
							bit = <0x2>;
						};
					};
#endif
#if defined(ERR_FG_Rising_edge) || defined(ERR_FG_TRUE)
					ADD_ID(err_fg): err-fg {
						gpios = <SEC_GPIO_REF(${err_fg_gpio}) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x00002001>;	/* RISING EDGE | ONE_SHOT */
					};

#endif
#if defined(ERR_FG_Falling_edge) || defined(ERR_FG_Falling_edge_pull_down)
					ADD_ID(err_fg): err-fg {
						gpios = <SEC_GPIO_REF(${err_fg_gpio}) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <2>;	/* Falling EDGE | ONE_SHOT */
					};
#endif
#if 1
					ADD_ID(conn_det): conn-det {
						gpios = <SEC_GPIO_REF(AP,gpc3,gpc3,0) 0>;
						dir = <1>;
						irq-type = <0x00002001>;	//RISING EDGE | ONE_SHOT
					};
#endif
#if 1
					ADD_ID(pcd): pcd {
						gpios = <SEC_GPIO_REF(AP,gpc6,gpc6,0) 1>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x2>;   /* FALLING EDGE */
					};
#endif
#if 0
					ADD_ID(disp_te): disp-te {
						gpios = <SEC_GPIO_REF(${disp_te_gpio}) 0>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x0>;   /* NONE */
					};
#endif
#if 0
					ADD_ID(avdd_en): avdd-en {
						gpios = <SEC_GPIO_REF(${avdd_en_gpio}) 0>;
						dir = <0>;
						irq-type = <0x0>;   /* NONE */
					};
#endif
#if 0
					ADD_ID(disp_reset_ready): disp_reset_ready {
						gpios = <SEC_GPIO_REF(${rst_ready_gpio}) 1>;		/* 0:NOK(active) 1:OK */
						dir = <1>;				/* IN */
						irq-type = <0x0>;   /* NONE */
					};
#endif

				};

				regulators {
#if 1
					ADD_ID(ddi_vci): ddi-vci {
						regulator = <&l32_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <3000000>;
					};
#endif
#if 1
					ADD_ID(ddi_vdd3): ddi-vdd3 {
						regulator = <&l22_reg>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1800000>;
					};
#endif
#if 0
					ADD_ID(ddr_vddr): ddr-vddr {
						regulator = <&${ddr_vddr_reg}>;
						type = <REGULATOR_TYPE_PWR>;
						def-voltage = <1600000>;
					};
#endif
#if 0
					ADD_ID(fd_elvdd): fd-elvdd {
						regulator = <&${fd_elvdd_reg}>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
#if 0
					ADD_ID(ssd_elvss): ssd-elvss {
						regulator = <&${ssd_elvss_reg}>;
						type = <REGULATOR_TYPE_SSD>;
					};
#endif
#if 0
					ADD_ID(dpmic_elvdd_elvss): dpmic-elvdd-elvss {
						regulator = <&${dpmic_elvdd_elvss_reg}>;
						type = <REGULATOR_TYPE_PWR>;
					};
#endif
				};
			};
		};
	};
};

/* #include "../input_berlin.dtsi" */                /* From input_berlin.py */
&pinctrl_1 {
	berlin_attn_irq: berlin_attn_irq {
		GPIO_CONFIG_PUD(AP,gpm2,gpm2,0, FUNC_INPUT_WAKEUP, PULL_NONE);
	};

	berlin_attn_irq_suspend: berlin_attn_irq_suspend {
		GPIO_CONFIG_PUD(AP,gpm2,gpm2,0, FUNC_INPUT, PULL_NONE);
	};
};

&hsi2c_13 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	tsp_goodix: touchscreen@5d {
		status = "okay";
		compatible = "goodix,berlin";
		reg = <0x5d>;
		pinctrl-names = "on_state", "off_state";
		pinctrl-0 = <&berlin_attn_irq>;
		pinctrl-1 = <&berlin_attn_irq_suspend>;
#if LEGO_IS_USE(fixed_regulator0, ...)
		tsp_io_ldo-supply = <&fixed_regulator0>;
#endif
#if LEGO_IS_USE(s_l13_reg, ...)
		tsp_avdd_ldo-supply = <&s_l13_reg>;
#endif
		sec,irq_gpio = <SEC_GPIO_REF(AP,gpm2,gpm2,0) 0x2002>;
		support_dex_mode;
		sec,enable_sysinput_enabled;
		support_open_short_test;
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/input/sec_input_2024/touchscreen/goodix/berlin/dts/input-lsi-tsp-berlin.a56x.01.dtsi */
&tsp_goodix {
	status = "okay";
	sec,enable_sysinput_enabled;
	sec,max_coords = <1080 2340>; /* x y */
	sec,firmware_name = "tsp_goodix/gt9916k_a56x.bin";

	sec,bringup = <0>;

	enable_settings_aot;
	support_ear_detect_mode;
	support_fod;
	support_fod_lp_mode;
	support_fod_control;
	support_gesture_uevent;
	support_vbus_notifier;
	not_support_temp_noti;

	goodix,enable_esd_check;
	goodix,ic_type = <3>; //GT9916K

	goodix,max_drv_num = <20>;
	goodix,max_sen_num = <40>;
	goodix,drv_map = <40 41 42 43 44 45 46 47
					48 49 50 51 52 53 54 55 56 57 58 59>;
	goodix,sen_map = <0 1 2 3 4 5 6 7 8 9 10 11 12
					13 14 15 16 17 18 19 20 21 22 23 24
					25 26 27 28 29 30 31 32 33 34 35 36
					37 38 39>;
	goodix,short_test_time_reg = <0x14D7A>;
	goodix,short_test_status_reg = <0x13400>;
	goodix,short_test_result_reg = <0x13408>;
	goodix,drv_drv_reg = <0x1344E>;
	goodix,sen_sen_reg = <0x137E6>;
	goodix,drv_sen_reg = <0x14556>;
	goodix,diff_code_reg = <0x14D00>;
	goodix,production_test_addr = <0x0000>; //unused

	goodix,switch_freq_cmd = <0xB1>;
	goodix,switch_cfg_cmd = <0x64>;
	goodix,snr_cmd = <0x65>;
	goodix,sensitive_cmd = <0x66>;

	goodix,isp_ram_reg = <0x23800>;
	goodix,flash_cmd_reg = <0x12400>;
	goodix,isp_buffer_reg = <0x12410>;
	goodix,config_data_reg = <0x3E000>;
	goodix,misctl_reg = <0xD804>;
	goodix,watch_dog_reg = <0xD040>;
	goodix,config_id_reg = <0x10076>;
	goodix,enable_misctl_val = <0x20700000>;
};


&hsi2c13_bus {
	samsung,pins = "gpm0-0", "gpm1-0";
	samsung,pin-function = <2>;
	samsung,pin-pud = <0>;
	samsung,pin-drv = <0>;
};

/* #include "../fingerprint_gw9558x.dtsi" */         /* From fingerprint_gw9558x.py */
/*
 * SAMSUNG EXYNOS9630 board device tree source
 *
 * Copyright (c) 2018 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

&pinctrl_0 {
	gw9558x_rst: gw9558x-rst {
		samsung,pins = SEC_GPIO(AP,gpa0,gpa0,6);
		samsung,pin-function = <1>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <1>;
	};
};

#if 0
&${fps_ldo_vdd_1p8_parent} {
	gw9558x_ldo: gw9558x-ldo {
		samsung,pins = SEC_GPIO(${fps_ldo_vdd_1p8});
		samsung,pin-function = <1>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <0>;
		samsung,pin-con-pdn = <3>;
		samsung,pin-pud-pdn = <1>;
	};
};
#endif

#if 1
&l2_reg {
	regulator-name = "VDD_BTP_3P3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	regulator-ramp-delay = <12000>;
};
#endif

&pinctrl_5 {
	spi_fp_bus_inactive: spi-fp-bus-inactive {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,7), SEC_GPIO(AP,gpp3,gpp3,4), SEC_GPIO(AP,gpp3,gpp3,5);
		samsung,pin-function = <1>;
		samsung,pin-pud = <0>;
		samsung,pin-drv = <1>;
		samsung,pin-val = <0>;
	};

	spi_fp_miso_inactive: spi-fp-miso-inactive {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,6);
		samsung,pin-function = <0>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <1>;
	};

	spi_fp_clk: spi-fp-clk {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,4);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};

	spi_fp_cs: spi-fp-cs {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,7);
		samsung,pin-function = <2>;
		samsung,pin-pud = <3>;
		samsung,pin-drv = <4>;
	};

	spi_fp_miso: spi-fp-miso {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,6);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};

	spi_fp_mosi: spi-fp-mosi {
		samsung,pins = SEC_GPIO(AP,gpp3,gpp3,5);
		samsung,pin-function = <2>;
		samsung,pin-pud = <1>;
		samsung,pin-drv = <4>;
	};
};

#if defined(CONFIG_SEC_FACTORY) || !1
&spi_13 {
	status = "okay";
	pinctrl-names = "";
	qos_trig_lvl = <51200>;
	int_qos_val = <100000>;
	dma-mode;
	swap-mode = <1>;
#else
&smd {
#endif
	gw9558 {
		compatible = "goodix,gw9558x";
		reg = <0>;
		spi-max-frequency = <25000000>;
		pinctrl-names = "default", "pins_poweron", "pins_poweroff";
#if 0
		pinctrl-0 = <&gw9558x_ldo &gw9558x_rst>;
#else
		pinctrl-0 = <&gw9558x_rst>;
#endif
		pinctrl-1 = <&spi_fp_clk &spi_fp_cs &spi_fp_miso &spi_fp_mosi>;
		pinctrl-2 = <&spi_fp_bus_inactive &spi_fp_miso_inactive>;

		gpio-controller;
		#gpio-cells = <2>;

#if 0
		goodix,gpio_pwr = <SEC_GPIO_REF(${fps_ldo_vdd_1p8}) 0>;
#endif
#if 1
		goodix,btp-regulator = "VDD_BTP_3P3";
		VDD_BTP_3P3-supply = <&l2_reg>;
#endif
		goodix,gpio_reset = <SEC_GPIO_REF(AP,gpa0,gpa0,6) 0>;
		goodix,chip_id = "GW9588";
		goodix,position = "12.34,0.00,9.10,9.10,14.80,14.80,12.00,12.00,5.00";
		goodix,modelinfo = "A566";
		goodix,rb = "647,-1,-1,FFFFFF";

		controller-data {
			cs-gpio = <SEC_GPIO_REF(AP,gpp3,gpp3,7) 0>;
			samsung,spi-feedback-delay = <0>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};
/* #include "../nfc_lsi_nfc_2.dtsi" */               /* From nfc_lsi_nfc_2.py */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#if 1
#if 0
&${ese_check_parent} {
	ese_check_default: ese_check_default {
		GPIO_CONFIG_PUD_DRV(${ese_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&pinctrl_3 {
	ese_spi_bus_suspend: ese_spi_bus_suspend {
		samsung,pins = SEC_GPIO(AP,gpp0,gpp0,0), SEC_GPIO(AP,gpp0,gpp0,1), SEC_GPIO(AP,gpp0,gpp0,2);
		samsung,pin-function = <0>; /* INPUT */
		samsung,pin-pud = <PIN_PULL_DOWN>; /* DOWN */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_DOWN>;
	};

	ese_spi_cs_suspend: ese_spi_cs_suspend {
		samsung,pins = SEC_GPIO(AP,gpp0,gpp0,3);
		samsung,pin-function = <1>; /* OUTPUT */
		samsung,pin-pud = <PIN_PULL_NONE>; /* NONE */
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
		samsung,pin-val = <1>;
		samsung,pin-con-pdn = <1>; /*OUT1*/
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	ese_spi_bus: ese_spi_bus {
		samsung,pins = SEC_GPIO(AP,gpp0,gpp0,0), SEC_GPIO(AP,gpp0,gpp0,1), SEC_GPIO(AP,gpp0,gpp0,2);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};

	ese_spi_cs: ese_spi_cs {
		samsung,pins = SEC_GPIO(AP,gpp0,gpp0,3);
		samsung,pin-function = <1>;
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-drv = <PIN_AP_DRV_LV1>;
	};
};

&spi_0 {
	status = "ok";
	pinctrl-names = "ese_active", "ese_suspend";
	pinctrl-0 = <&ese_spi_bus &ese_spi_cs>;
	pinctrl-1 = <&ese_spi_bus_suspend &ese_spi_cs_suspend>;

	ese_spi@0 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "ese_p3";
		reg = <0>;
		spi-max-frequency = <7000000>;
#if 0
		check_ese = <SEC_GPIO_REF(${ese_check}) 0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ese_check_default>;
#endif
		gpio-controller;
		#gpio-cells = <2>;
#if 0
		p3-vdd-supply = <&${ese_pvdd_ldo}>;
#endif
		ese_p3,cs-gpio = <SEC_GPIO_REF(AP,gpp0,gpp0,3) 0>;
		controller-data {
			samsung,spi-feedback-delay = <0>;
			samsung,spi-chip-select-mode = <0>;
		};
	};
};

#if 0
&${ese_pvdd_ldo} {
	regulator-name = "p3-vdd";
};
#endif

#if 0
/ {
	fragment@ese_platform {
		target-path = "/";
		__overlay__ {
			ese_platform {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
				status = "disabled";
#else
				status = "ok";
#endif
				compatible = "p3_platform";
			};
		};
	};
};
#endif
#endif

&pinctrl_3 {
	nfc_i2c_pull_none: nfc_i2c_pull_none {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,2), SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <3>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_NONE>;
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

#if 1
	nfc_i2c_no_change: nfc_i2c_no_change {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,2), SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <3>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
	};
	nfc_i2c_pull_up: nfc_i2c_pull_up {
		samsung,pins = SEC_GPIO(AP,gpp1,gpp1,2), SEC_GPIO(AP,gpp1,gpp1,3);
		samsung,pin-function = <3>;
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud = <PIN_PULL_UP>;
		samsung,pin-pud-pdn = <PIN_PULL_UP>;
	};
#endif
};

#if 0
&${xclkout_parent} {
	xclkout: xclkout {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_NONE>;
	};

	xclkout_nc: xclkout_nc {
		samsung,pins = SEC_GPIO(${xclkout_gpio});
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};
#endif

&pinctrl_0 {
	nfc_firm: nfc_firm {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,2, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_firm_nc: nfc_firm_nc {
		GPIO_CONFIG_PUD_DRV(AP,gpa1,gpa1,2, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&pinctrl_0 {
	nfc_en: nfc_en {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,1, FUNC_OUTPUT_LOW, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <3>; /* PIN_PDN_PREV */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};

	nfc_en_nc: nfc_en_nc {
		GPIO_CONFIG_PUD_DRV(AP,gpa0,gpa0,1, FUNC_INPUT, PULL_DOWN, DRV_LV3);
	};
};

&pinctrl_0 {
	nfc_clk_req: nfc_clk_req {
		samsung,pins = SEC_GPIO(AP,gpa1,gpa1,1);
		samsung,pin-function = <2>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};

	nfc_clk_req_nc: nfc_clk_req_nc {
		samsung,pins = SEC_GPIO(AP,gpa1,gpa1,1);
		samsung,pin-function = <0>;
		samsung,pin-pud = <PIN_PULL_DOWN>;
	};
};

#if 0
&${nfc_check_parent} {
	nfc_check: nfc_check {
		GPIO_CONFIG_PUD_DRV(${nfc_check}, FUNC_INPUT, PULL_NONE, DRV_LV3);
		samsung,pin-con-pdn = <2>; /* PIN_PDN_INPUT */
		samsung,pin-pud-pdn = <PIN_PULL_NONE>;
	};
};
#endif

&hsi2c_5 {
	#address-cells = <1>;
	#size-cells = <0>;

	status = "ok";
	clock-frequency = <400000>; /* for HSI2C */
	samsung,i2c-max-bus-freq = <400000>; /* for Normal HW I2C */
	samsung,reset-before-trans;
#if 1
	pinctrl-names = "default", "i2c_pull_up";
	pinctrl-0 = <&nfc_i2c_no_change>;
	pinctrl-1 = <&nfc_i2c_pull_up>;
#else
	pinctrl-names = "default";
	pinctrl-0 = <&nfc_i2c_pull_none>;
#endif
	sec_nfc: sec-nfc@27 {
#if defined(CONFIG_SEC_FACTORY_INTERPOSER) && 1
		status = "disabled";
#else
		status = "ok";
#endif
		compatible = "sec-nfc";
		reg = <0x27>;

		interrupts = <SEC_GPIO_NUM(AP,gpa1,gpa1,3) 0 0>;
		interrupt-parent = <SEC_GPIO_TYPE(AP,gpa1,gpa1,3)>;

		sec-nfc,ven-gpio = <SEC_GPIO_REF(AP,gpa0,gpa0,1) 0>;
		sec-nfc,firm-gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,2) 0>;
		sec-nfc,irq-gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,3) 0>;
#if 0
		sec-nfc,check_nfc = <SEC_GPIO_REF(${nfc_check}) 0>;
#endif
		sec-nfc,clk_req-gpio = <SEC_GPIO_REF(AP,gpa1,gpa1,1) 0xf>;
#if 1
		sec-nfc,coldreset-gpio = <SEC_GPIO_REF(AP,gpp1,gpp1,1) 0>;
#endif
		nfc_pvdd-supply = <&fixed_regulator1>;

		sec-nfc,ldo_control;

#if 0
		sec-nfc,irq_all_trigger;
#endif
#if 0
		sec-nfc,eint_mode;
#endif
#if 0
		clocks = <&clock OSC_NFC>;
		clock-names = "oscclk_nfc";
		sec-nfc,nfc_ap_clk;
#endif
		sec-nfc,nfc_ic_type = "SEN6";

		pinctrl-names = "default", "nfc_nc";
		pinctrl-0 = <&nfc_en &nfc_firm &nfc_clk_req
#if 0
				&nfc_check
#endif
#if 0
				&xclkout
#endif
				>;
		pinctrl-1 = <&nfc_en_nc &nfc_firm_nc &nfc_clk_req_nc
#if 0
				&xclkout_nc
#endif
				>;
	};
};

&fixed_regulator1 {
	regulator-name = "nfc_pvdd";
};


/* #include "../s2mf301_charger.dtsi" */             /* From s2mf301_charger.py */
&smd {
	s2mf301_charger: s2mf301-charger {
		status = "disable";
		compatible = "samsung,s2mf301-charger";
	};

	battery {
		battery,otg_name = "s2mf301-otg";
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/charger/s2mf301/s2mf301_charger.a56x.dtsi */
&s2mf301_charger {
	charger,bat2ship_debounce_time = <16>;
	charger,bat2ship_debounce_time_factory_bin = <16>;
};


/* #include "../sec_direct_charger.dtsi" */          /* From sec_direct_charger.py */

&smd {
	sec-direct-charger {
		status = "okay";
		compatible = "samsung,sec-direct-charger";

		charger,battery_name = "battery";
		charger,main_charger = "s2mf301-charger";
		charger,direct_charger = "nu2111a-charger";

	#if 0
		charger,direct_chargers =
				"nu2111a-charger",
				"${direct_charger_name2}";
	#endif

		charger,dchg_min_current = <2000>;

		charger,ta_alert_wa;
	};
};


/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/common/sec_direct_charger/dts/a56x/sec_direct_charger.dtsi */

&smd {
	pass-through {
		start_delay = <5000>; /* msec */
		init_delay = <5000>; /* msec */
		min_cap = <200>; /* 0.1 % */
		fixed_sc_cap = <900>; /* 0.1 % */
		max_icl = <3000>; /* mA */
	};
};


/* #include "../battery_common.dtsi" */              /* From battery_common.py */
#include <dt-bindings/battery/sec-battery.h>

&smd {
	sec_battery: battery {
		status = "okay";
		compatible = "samsung,sec-battery";
		battery,vendor = "Battery";
		battery,charger_name = "sec-direct-charger";
		battery,fuelgauge_name = "s2mf301-fuelgauge";
		battery,technology = <2>; /* POWER_SUPPLY_TECHNOLOGY_LION */
		battery,chip_vendor = "NONE";

		battery,batt_data_version = <1>;

		battery,adc_check_count = <5>;
		battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,wpc_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;
		battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_NONE>;

		battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */
		battery,wpc_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_NONE>; /* SEC_BATTERY_THERMAL_SOURCE_NONE */

		battery,inbat_ocv_type =  <SEC_BATTERY_OCV_NONE>;

		battery,polling_time = <10 30 30 30 3600>;

		battery,cable_check_type = <SEC_BATTERY_CABLE_CHECK_PSY>;
		battery,cable_source_type = <SEC_BATTERY_CABLE_SOURCE_EXTERNAL>;
		battery,polling_type = <SEC_BATTERY_MONITOR_ALARM>; /* SEC_BATTERY_MONITOR_ALARM */
		battery,monitor_initial_count = <0>;

		battery,battery_check_type = <0>; /* SEC_BATTERY_CHECK_NONE */

		battery,ovp_uvlo_check_type = <SEC_BATTERY_OVP_UVLO_CHGPOLLING>; /* SEC_BATTERY_OVP_UVLO_CHGPOLLING */

		battery,temp_check_count = <1>;

		battery,usb_protection_temp = <610>;
		battery,temp_gap_bat_usb = <200>;
		battery,overheatlimit_threshold = <700>;
		battery,overheatlimit_recovery = <680>;
		battery,wire_warm_overheat_thresh = <500>;
		battery,wire_normal_warm_thresh = <420>;
		battery,wire_cool1_normal_thresh = <180>;
		battery,wire_cool2_cool1_thresh = <150>;
		battery,wire_cool3_cool2_thresh = <50>;
		battery,wire_cold_cool3_thresh = <0>;
		battery,wireless_warm_overheat_thresh = <500>;
		battery,wireless_normal_warm_thresh = <420>;
		battery,wireless_cool1_normal_thresh = <180>;
		battery,wireless_cool2_cool1_thresh = <150>;
		battery,wireless_cool3_cool2_thresh = <50>;
		battery,wireless_cold_cool3_thresh = <0>;
		battery,tx_high_threshold = <500>;
		battery,tx_high_recovery = <450>;
		battery,tx_low_threshold = <0>;
		battery,tx_low_recovery = <50>;

		battery,wire_warm_current = <1573>;	/* 0.36C */
		battery,wire_cool1_current = <3146>;	/* 0.72C */
		battery,wire_cool2_current = <1048>;	/* 0.24C */
		battery,wire_cool3_current = <437>;	/* 0.1C */
		battery,wireless_warm_current = <1048>;		/* 0.24C */
		battery,wireless_cool1_current = <3146>;	/* 0.72C */
		battery,wireless_cool2_current = <1048>;	/* 0.24C */
		battery,wireless_cool3_current = <437>;		/* 0.1C */

		battery,full_check_type = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_CHGPSY>;
		battery,full_check_count = <1>;
		battery,chg_gpio_full_check = <0>;
		battery,chg_polarity_full_check = <1>;

		battery,chg_high_temp = <470>;
		battery,chg_high_temp_recovery = <450>;
		battery,chg_input_limit_current = <1000>;
		battery,chg_charging_limit_current = <1900>;

		battery,dchg_high_temp = <520>;
		battery,dchg_high_temp_recovery = <460>;
		battery,dchg_high_batt_temp = <400>;
		battery,dchg_high_batt_temp_recovery = <380>;
		battery,dchg_input_limit_current = <1000>;
		battery,dchg_charging_limit_current = <2000>;

		battery,wpc_temp_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_high_temp = <400>;
		battery,wpc_high_temp_recovery = <380>;
		battery,wpc_input_limit_current = <800>;
		battery,wpc_charging_limit_current = <1000>;
		battery,wpc_temp_lcd_on_control_source = <TEMP_CONTROL_SOURCE_BAT_THM>;
		battery,wpc_lcd_on_input_limit_current = <800>;

		battery,wpc_store_high_temp = <360>;
		battery,wpc_store_high_temp_recovery = <340>;
		battery,wpc_store_charging_limit_current = <400>;
		battery,wpc_store_lcd_on_high_temp = <360>;
		battery,wpc_store_lcd_on_high_temp_rec = <300>;
		battery,wpc_store_lcd_on_charging_limit_current = <400>;

		battery,fcc_by_tx = <1200>;

		battery,sleep_mode_limit_current = <800>;
		battery,wc_full_input_limit_current = <100>;

		battery,ta_alert_wa;

		battery,mix_high_temp = <420>;
		battery,mix_high_chg_temp = <500>;
		battery,mix_high_temp_recovery = <390>;

		/* battery,usb_conn_slope_avg = <9>; */

		/* battery,enable_mix_v2; */
		/* if you want to use mix_v2 concept, add "battery,enable_mix_v2;" */
		battery,mix_v2_lrp_recov = <460>;
		battery,mix_v2_lrp_cond = <480>;
		battery,mix_v2_bat_cond = <480>;
		battery,mix_v2_chg_cond = <0>;	/* 0 means no use chg thm condition */
		battery,mix_v2_dchg_cond = <0>; /* 0 means no use dchg thm condition */

		battery,full_condition_type = <(SEC_BATTERY_FULL_CONDITION_NOTIMEFULL | SEC_BATTERY_FULL_CONDITION_VCELL)>;
		battery,full_condition_soc = <93>;
		/* battery,full_condition_vcell = FV - 50mV set when variable is parsed */

		battery,recharge_check_count = <1>;
		battery,recharge_condition_type = <SEC_BATTERY_RECHARGE_CONDITION_VCELL>;
		battery,recharge_condition_soc = <98>;
		/* battery,recharge_condition_vcell = FV - 70mV set when variable is parsed */

		battery,charging_reset_time = <0>;

		battery,chg_float_voltage = <4350>;

		battery,pre_afc_work_delay = <2000>;
		battery,pre_wc_afc_work_delay = <4000>;
		battery,pre_afc_input_current = <500>;
		battery,pre_wc_afc_input_current = <500>;

		battery,swelling_high_rechg_voltage = <4000>;
		/*battery,swelling_low_rechg_voltage = FV - 150mA set when variable is parsed */

		battery,siop_icl = <1200>;
		battery,siop_fcc = <1800>;
		battery,siop_hv_icl = <700>;
		battery,siop_hv_icl_2nd = <550>;
		battery,siop_hv_fcc = <1800>;
		battery,siop_apdo_icl = <1000>;
		battery,siop_apdo_fcc = <2000>;

		battery,siop_wpc_icl = <600>;
		battery,siop_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_hv_wpc_icl = <700>;
		battery,siop_hv_wpc_fcc = <1000 500 100>; /* siop_level 70 10 0 */
		battery,siop_store_hv_wpc_icl = <450>;
		battery,store_mode_buckoff;

		/* trig, recov */
		battery,temp_table_LRP_45W = <385 365>;

		battery,rp_current_rp1 = <500>;
		battery,rp_current_rp2 = <1500>;
		battery,rp_current_rp3 = <3000>;
		battery,rp_current_rdu_rp3 = <2100>;
		battery,rp_current_abnormal_rp3 = <1800>;

		battery,pd_charging_charge_power = <15000>;
		battery,max_charging_current = <2350>;

		battery,store_mode_charging_max = <70>;
		battery,store_mode_charging_min = <60>;

		battery,wireless_cc_cv = <85>;
		battery,wireless_otg_input_current = <900>;

		/* Calculate Based on Offsets from float voltage, full_condition_vcell and recharge_condition_vcell */
		/* if you want to use age_data_by_common_offset concept add battery,age_data_by_common_offset; */

		battery,age_data_cycle = <0 300 400 700 1000>;
		battery,age_data_full_condition_soc = <93 92 91 90 89>;
		battery,age_data_common_offset = <0 20 40 110>;
		/* battery,age_data_max_charging_current_offset = <0 100 200 300 400>; */

		/* cycle, chg_float_voltage, recharge_condition_vcell, full_condition_vcell, full_condition_soc, step charging condition */
		battery,age_data = <0 4350 4280 4250 93
			300 4330 4260 4230 92
			400 4310 4240 4210 91
			700 4290 4220 4190 90
			1000 4240 4170 4140 89>;


		battery,health_condition_cycle = <900 1200 1500>;
		battery,health_condition_asoc = <0 0 0>; /* Default ASOC Disabled */

		battery,max_input_voltage = <9000>; /* mV */
		battery,max_input_current = <3000>;  /* mA */

		battery,cisd_alg_index = <8>;
		battery,cisd_max_voltage_thr = <4400>; /* batttery ovp dettection voltage */
		battery,ignore_cisd_index = <0 0>;
		battery,ignore_cisd_index_d = <0 80>; /* Do not use BUCK_OFF_PER_DAY, DROP_SENSOR_PER_DAY */

		battery,expired_time = <10800>;
		battery,recharging_expired_time = <5400>;

		battery,battery_full_capacity = <3300>;

		battery,ttf_capacity = <3500>;
		battery,cv_data = <
				3228	864	1534
				3133	866	1524
				3067	872	1493
				3019	874	1483
				2929	879	1452
				2896	881	1442
				2843	883	1431
				2792	885	1421
				2754	887	1411
				2695	892	1380
				2660	893	1370
				2625	895	1360
				2580	897	1349
				2531	898	1339
				2492	902	1319
				2450	903	1309
				2410	905	1298
				2348	908	1278
				2296	909	1268
				2263	910	1257
				2214	915	1227
				2182	916	1216
				2147	919	1196
				2103	920	1186
				2051	922	1175
				2019	924	1155
				1981	927	1134
				1948	928	1124
				1911	930	1104
				1879	932	1093
				1834	933	1083
				1795	935	1063
				1761	938	1032
				1722	942	1001
				1689	944	981
				1649	946	960
				1592	948	940
				1532	950	919
				1493	954	878
				1462	955	868
				1410	958	827
				1362	959	817
				1338	960	807
				1291	964	756
				1264	968	715
				1237	968	704
				1213	969	694
				1169	974	633
				1127	975	622
				1105	975	612
				1073	980	541
				1049	982	510
				1010	983	489
				993	984	479
				972	986	448
				955	988	407
				932	990	387
				881	990	377
				864	996	356
				761	1000	307
				710	1000	297
				688	1000	287
				668	1000	235
				658	1000	215
				647	1000	184
				635	1000	153
				622	1000	123
				610	1000	92
				596	1000	61
				583	1000	31
				571	1000	0
				>;

#if 1
		io-channels = <&s2mpu15_gpadc 2>, <&s2mpu15_gpadc 3>, <&s2mpu15_gpadc 9>;
		io-channel-names = "adc-temp", "adc-chg-temp", "adc-usb-temp", "n/a", "n/a", "n/a", "n/a", "n/a";
#endif
#if 0
	/*EUR_DETECTION_NODE*/
	battery,eur_detection = <SEC_GPIO_REF(${eur_detection}) 0 >;
#endif
	};

	/* sec_battery_cable
	 *   0	UNKNOWN,
	 *   1	NONE,
	 *   2	PREPARE_TA,
	 *   3	TA,
	 *   4	USB,
	 *   5	USB_CDP,
	 *   6	9V_TA,
	 *   7	9V_ERR,
	 *   8	9V_UNKNOWN,
	 *   9	12V_TA,
	 *  10	WIRELESS,
	 *  11	HV_WIRELESS,
	 *  12	PMA_WIRELESS,
	 *  13	WIRELESS_PACK,
	 *  14	CABLE_WIRELESS_HV_PACK,
	 *  15	WIRELESS_STAND,
	 *  16	WIRELESS_HV_STAND,
	 *  17	QC20,
	 *  18	QC30,
	 *  19	PDIC,
	 *  20	UARTOFF,
	 *  21	OTG,
	 *  22	LAN_HUB,
	 *  23	POWER_SHARING,
	 *  24	HMT_CONNECTED,
	 *  25	HMT_CHARGE,
	 *  26	HV_TA_CHG_LIMIT,
	 *  27	WIRELESS_VEHICLE,
	 *  28	WIRELESS_HV_VEHICLE,
	 *  29	PREPARE_WIRELESS_HV,
	 *  30  TIMEOUT,
	 *  31  SMART_OTG,
	 *  32  SMART_NOTG,
	 *  33  WIRELESS_TX,
	 *  34	HV_WIRELESS_20,
	 *  35	HV_WIRELESS_20_LIMIT,
	 *  36	WIRELESS_FAKE,
	 *  37  PREPARE_WIRELESS_20,
	 *  38	CABLE_PDIC_APDO,
	 *  39  CABLE_POGO,
	 *  40  CABLE_POGO_9V,
	 *  41  FPDO_DC,
	 *  42	CABLE_MAX,
	 */
	sec_battery_cable: cable-info {
		default_input_current = <1800>;
		default_charging_current = <2100>;
		full_check_current_1st = <350>;
		full_check_current_2nd = <200>;

		current_group_1 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_TA
				SEC_BATTERY_CABLE_PDIC
				SEC_BATTERY_CABLE_OTG
				SEC_BATTERY_CABLE_LAN_HUB
				SEC_BATTERY_CABLE_POWER_SHARING>;
			input_current = <500>;
			charging_current = <500>;
		};
		current_group_2 {
			cable_number = <
				SEC_BATTERY_CABLE_HMT_CHARGE
				SEC_BATTERY_CABLE_SMART_OTG>;
			input_current = <1000>;
			charging_current = <1000>;
		};
		current_group_3 {
			cable_number = <
				SEC_BATTERY_CABLE_USB_CDP
				SEC_BATTERY_CABLE_SMART_NOTG>;
			input_current = <1500>;
			charging_current = <1500>;
		};
		current_group_4 {
			cable_number = <SEC_BATTERY_CABLE_9V_TA SEC_BATTERY_CABLE_9V_ERR
				SEC_BATTERY_CABLE_9V_UNKNOWN SEC_BATTERY_CABLE_QC20 SEC_BATTERY_CABLE_QC30>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_5 {
			cable_number = <SEC_BATTERY_CABLE_12V_TA>;
			input_current = <1650>;
			charging_current = <2350>;
		};
		current_group_6 {
			cable_number = <
				SEC_BATTERY_CABLE_WIRELESS
				SEC_BATTERY_CABLE_PMA_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_STAND
				SEC_BATTERY_CABLE_WIRELESS_VEHICLE
				SEC_BATTERY_CABLE_WIRELESS_FAKE>;
			input_current = <800>;
			charging_current = <2350>;
		};
		current_group_7 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_PACK>;
			input_current = <700>;
			charging_current = <2350>;
		};
		current_group_8 {
			cable_number = <SEC_BATTERY_CABLE_HMT_CONNECTED>;
			input_current = <1000>;
			charging_current = <450>;
		};
		current_group_9 {
			cable_number = <SEC_BATTERY_CABLE_HV_TA_CHG_LIMIT>;
			input_current = <1800>;
			charging_current = <1800>;
		};
		current_group_10 {
			cable_number = <
				SEC_BATTERY_CABLE_HV_WIRELESS
				SEC_BATTERY_CABLE_WIRELESS_HV_PACK
				SEC_BATTERY_CABLE_WIRELESS_HV_STAND
				SEC_BATTERY_CABLE_WIRELESS_HV_VEHICLE
				SEC_BATTERY_CABLE_HV_WIRELESS_20_LIMIT>;
			input_current = <650>;
			charging_current = <2350>;
		};
		current_group_11 {
			cable_number = <
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_HV
				SEC_BATTERY_CABLE_PREPARE_WIRELESS_20>;
			input_current = <500>;
			charging_current = <1200>;
		};
		current_group_12 {
			cable_number = <
				SEC_BATTERY_CABLE_NONE
				SEC_BATTERY_CABLE_USB
				SEC_BATTERY_CABLE_TIMEOUT>;
			input_current = <475>;
			charging_current = <550>;
		};
		current_group_13 {
			cable_number = <SEC_BATTERY_CABLE_HV_WIRELESS_20>;
			input_current = <1200>;
			charging_current = <2350>;
		};
		current_group_14 {
			cable_number = <SEC_BATTERY_CABLE_WIRELESS_TX>;
			input_current = <800>;
			charging_current = <2350>;
		};
	};
	sec_battery_wireless_power_info: wireless-power-info {
		count = <11>;
		current_group_0 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <830>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_1 {
			wireless_power_class = <2>;
			vout = <10000>;
			input_current_limit = <750>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_2 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <680>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_3 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <625>;
			fast_charging_current = <3150>;
			ttf_charge_current = <1500>;
			rx_power = <7500>;
		};
		current_group_4 {
			wireless_power_class = <2>;
			vout = <9000>;
			input_current_limit = <1330>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2175>;
			rx_power = <12000>;
		};
		current_group_5 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1090>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_6 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1000>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2100>;
			rx_power = <12000>;
		};
		current_group_7 {
			wireless_power_class = <2>;
			vout = <11000>;
			input_current_limit = <1360>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
		current_group_8 {
			wireless_power_class = <2>;
			vout = <12000>;
			input_current_limit = <1250>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
		current_group_9 {
			wireless_power_class = <2>;
			vout = <13000>;
			input_current_limit = <1150>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <15000>;
		};
		current_group_10 {
			wireless_power_class = <2>;
			vout = <10000>;
			input_current_limit = <1100>;
			fast_charging_current = <3150>;
			ttf_charge_current = <2300>;
			rx_power = <11000>;
		};
	};
};

/* /home/dpi/qb5_8814/workspace/P4_1716/kernel/kmodule/battery/suwon/common/dts/a56x/battery_common.dtsi */
#include <dt-bindings/battery/sec-battery.h>

#define MAX_FV 4480
#define MAX_FCC 3150
#define STD_CURR 4580

&sec_battery {
	pinctrl-names = "default";

	battery,chip_vendor = "LSI";

	battery,temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,chg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,dchg_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,usb_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;
	battery,lrp_temp_check_type = <SEC_BATTERY_TEMP_CHECK_TEMP>;

	battery,thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,chg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,dchg_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,usb_thermal_source = <SEC_BATTERY_THERMAL_SOURCE_ADC>;
	battery,dctp_by_cgtp;

	battery,temp_table_adc = <
		288 338 394 462 542 635 740 874 1018 1183
		1370 1584 1821 2005 2210 2447 2680 2909 3128 3321
		3476 3615 3711
		>;
	battery,temp_table_data = <
		900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,chg_temp_table_adc = <
		271 320 377 443 522 614 715 848 990 1155
		1340 1553 1784 1969 2171 2409 2643 2875 3098 3291
		3453 3595 3718
		>;
	battery,chg_temp_table_data = <
		900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,usb_temp_table_adc = <
		290 339 396 465 545 638 743 877 1022 1187
		1375 1589 1826 2011 2214 2452 2684 2913 3132 3325
		3479 3616 3713
		>;
	battery,usb_temp_table_data = <
		900 850 800 750 700 650 600 550 500 450
		400 350 300 250 200 150 100 50 0 (-50)
		(-100) (-150) (-200)
		>;

	battery,support_usb_conn_check; /* USB connection protection - ver3 */
	battery,mass_with_usb_thm;
	battery,usb_protection_temp = <500>;
	battery,temp_gap_bat_usb = <150>;

	battery,wire_cool3_cool2_thresh = <80>;
	battery,wire_warm_current = <3530>;
	battery,wire_cool1_current = <MAX_FCC>;	/* Less than or equal to 0.72C */
	battery,wire_cool2_current = <1170>;	/* 0.24C */
	battery,wire_cool3_current = <450>;	/* 0.1C */

	battery,chg_high_temp = <590>;
	battery,chg_high_temp_recovery = <550>;
	battery,chg_input_limit_current = <1000>;
	battery,chg_charging_limit_current = <2400>;

	battery,mix_high_temp = <420>;
	battery,mix_high_chg_temp = <650>;
	battery,mix_high_temp_recovery = <390>;

	/* 45w pwr on, 45w pwr off, 25w pwr on, 25w pwr off */
	battery,dchg_high_temp = <1000 1000 590 590>;
	battery,dchg_high_temp_recovery = <1000 1000 550 550>;
	battery,dchg_high_batt_temp = <1000 1000 1000 1000>; /* DISABLED */
	battery,dchg_high_batt_temp_recovery = <1000 1000 1000 1000>; /* DISABLED */
	battery,dchg_dc_in_swelling;

	battery,full_check_type = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;
	battery,full_check_type_2nd = <SEC_BATTERY_FULLCHARGED_FG_CURRENT>;

	battery,chg_float_voltage = <MAX_FV>;
	battery,high_temp_float = <4230>;
	battery,low_temp_float = <MAX_FV>;
	battery,swelling_high_rechg_voltage = <4080>;
	battery,chgen_over_swell_rechg_vol;

	battery,siop_hv_icl = <675>;
	battery,siop_scenarios = <0>;
	battery,siop_curr_type_num = <4>;
	/* nv, hv, fpdo, apdo */
	battery,siop_icl_0 = <SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT SIOP_DEFAULT>;
	battery,siop_fcc_0 = <100 100 100 100>;

	battery,chg_ocp_current = <0>;

	battery,max_charging_current = <MAX_FCC>;
	battery,max_charging_charge_power = <45000>; /* 45W */

	/* trig_step2_LCD_OFF, recov_step2_LCD_OFF, trig_step1_LCD_OFF , recov_step1_LCD_OFF,
	   trig_step2_LCD_ON, recov_step2_LCD_ON, trig_step1_LCD_ON , recov_step1_LCD_ON,
	   st1_icl, st1_fcc, st2_icl, st2_fcc */
	battery,temp_table_LRP_NORMAL = <
						390 380 380 370
						390 380 380 370
						1000 2400 1200 1800>;
	battery,temp_table_LRP_25W = <
						400 390 380 370
						400 390 380 370
						1700 3400 1100 2200>;

	battery,temp_table_LRP_45W = <
						407 397 387 377
						407 397 387 377
						1700 3400 1100 2200>;

	/* cycle, full_condition_soc, common_offset */
	battery,age_data_by_common_offset; /* Calculate Based on Common Offset */
	battery,age_data_cycle = <0 200 250 300 1001>;
	battery,age_data_full_condition_soc = <93 92 91 90 89>;
	battery,age_data_common_offset = <0 20 40 60 110>;
	battery,en_batt_full_status_usage;

	/* step charging option */
	battery,step_chg_type = <0>;

	/* direct step charging option */
	battery,dc_step_chg_type = <0xE9>;
	battery,dc_step_chg_charge_power = <22000>;
	battery,dc_step_chg_step = <4>;
	battery,dc_step_chg_cond_vol = <4080 4140 4280 MAX_FV>; /*<45w 4step> STEP_CHARGING_CONDITION_VOLTAGE */
	battery,dc_step_chg_val_vfloat = <4080 4140 4280 MAX_FV>; /* <45w 4step> STEP_CHARGING_CONDITION_FLOAT_VOLTAGE */
	battery,dc_step_chg_val_iout = <9200 7700 6500 STD_CURR>; /* <45w 4step> */
	battery,dc_step_chg_iin_check_cnt = <3>;
	battery,dc_step_chg_cond_soc = <11 40 63 100>; /* <45w 4step> STEP_CHARGING_CONDITION_SOC */

	battery,standard_curr = <STD_CURR>;
	battery,expired_time = <8340>; /* 79 + 60 minutes = 139 */
	battery,recharging_expired_time = <5400>; /* 90 minutes */
	battery,battery_full_capacity = <5000>;
	battery,cisd_max_voltage_thr = <5000>; /* batttery ovp dettection voltage */

	battery,ttf_hv_charge_current = <2993>;
	battery,ttf_dc25_charge_current = <5157>;
	battery,ttf_dc45_charge_current = <6150>;
	battery,ttf_capacity = <4900>;
	battery,cv_data = <
			4165	850	1731
			3764	870	1673
			3109	890	1570
			2613	910	1448
			2062	930	1295
			1541	950	1090
			1140	970	814
			593	990	213
			458	1000	0
		>;

	battery,support_vpdo;
	battery,boosting_voltage_aicl;
	battery,ap_wake_chg;
};

&sec_battery_cable {
	full_check_current_1st = <490>;
	full_check_current_2nd = <250>;

	current_group_4 {
		charging_current = <MAX_FCC>;
	};
	current_group_5 {
		charging_current = <MAX_FCC>;
	};
};

/* revision devicetree for general */
#include "s5e8855.a56x_eur_open.01.dtsi"

/ {
	compatible = "SAMSUNG,A56X_EUR_OPEN","SAMSUNG,S5E8855";
	dtbo-hw_rev = <1>;
	dtbo-hw_rev_end = <1>;
};
